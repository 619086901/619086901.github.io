(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{522:function(v,_,n){"use strict";n.r(_);var r=n(3),t=Object(r.a)({},(function(){var v=this,_=v.$createElement,n=v._self._c||_;return n("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"title"}),n("p",[v._v("我个人考三级整理的资料，背了肯定过~~\n{}的是填空题。")])]),v._v(" "),n("h2",{attrs:{id:"第一章"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#第一章"}},[v._v("#")]),v._v(" 第一章")]),v._v(" "),n("p",[v._v("数据库管理系统提供了数据定义语言（DDL），用于定义各种数据库对象。数据定义语句经 DDL 编译器编译后，各种对象的描述信息存放在数据库的（"),n("strong",[v._v("数据字典")]),v._v("）中。\n解析：数据字典是对系统中各类数据描述的集合，是进行详细的数据收集和数据分析所获得的主要成果。数据字典在数据库设计中占有很重要的地位，通常包括"),n("strong",[v._v("数据项、数据结构、数据流、数据存储和处理过程")]),v._v(" 5 个部分。")]),v._v(" "),n("p",[n("strong",[v._v("关系模式")]),v._v("描述关系的"),n("strong",[v._v("静态")]),v._v("结构，它是静态、稳定的。\n关系是动态随用户操作而变化。")]),v._v(" "),n("p",[v._v("模式/内模式保证了数据库中数据与应用程序间的"),n("strong",[v._v("物理")]),v._v("独立性。\n外模式/模式保证了数据与应用程序间的"),n("strong",[v._v("逻辑")]),v._v("独立性。")]),v._v(" "),n("h3",{attrs:{id:"视图的特点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#视图的特点"}},[v._v("#")]),v._v(" 视图的特点：")]),v._v(" "),n("ol",[n("li",[v._v("简化数据查询语句。")]),v._v(" "),n("li",[v._v("使用户从多角度看待同一数据。")]),v._v(" "),n("li",[v._v("提高数据安全性。")]),v._v(" "),n("li",[v._v("提供了一定程度的"),n("strong",[v._v("逻辑独立性")]),v._v("。")])]),v._v(" "),n("p",[v._v("数据库应用系统（DBAS）设计包括"),n("strong",[v._v("概念设计、逻辑设计、物理设计")]),v._v("。\n概念设计：采用"),n("strong",[v._v("自下而上")]),v._v("的 E-R 设计。\n物理设计：关系模式转换为具体 DBMS 平台支持的关系"),n("strong",[v._v("表")]),v._v("。\n逻辑设计："),n("strong",[v._v("设计")]),v._v("视图和关系模式的完整性约束。")]),v._v(" "),n("p",[n("strong",[v._v("概念数据模型")]),v._v("没有描述数据的完整性约束条件。")]),v._v(" "),n("h3",{attrs:{id:"数据库应用系统-dbas"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据库应用系统-dbas"}},[v._v("#")]),v._v(" 数据库应用系统（DBAS）")]),v._v(" "),n("p",[n("strong",[v._v("逻辑")]),v._v("设计阶段：")]),v._v(" "),n("ol",[n("li",[v._v("数据库逻辑结构设计。")]),v._v(" "),n("li",[v._v("数据库事务概要设计。")]),v._v(" "),n("li",[v._v("应用程序概要设计。\n"),n("strong",[v._v("物理")]),v._v("设计阶段：")]),v._v(" "),n("li",[v._v("确定存储结构。")]),v._v(" "),n("li",[v._v("存取路径的选择和调整。")]),v._v(" "),n("li",[v._v("确定数据存放位置和确定存储分配。")]),v._v(" "),n("li",[v._v("数据库物理结构设计、数据库事务详细设计、应用程序详细设计")])]),v._v(" "),n("p",[v._v("数据库物理设计包括：数据库逻辑模式描述、文件组织与存取设计（为"),n("strong",[v._v("表")]),v._v("设计索引、设计数据分区方案）、数据分布设计（设计数据分布策略）、确定系统配置、物理模式评估。")]),v._v(" "),n("p",[v._v("数据库"),n("strong",[v._v("逻辑设计")]),v._v("的主要步骤包括："),n("strong",[v._v("ER 图")]),v._v("转换为"),n("strong",[v._v("初始关系")]),v._v("模式、对初始关系模式进行优化。")]),v._v(" "),n("p",[v._v("数据库概念设计阶段，将具有相同属性特征的同类对象抽象为实体集，然后用一个有意义的名词或名词短语为每一个"),n("strong",[v._v("实体集")]),v._v("命名。")]),v._v(" "),n("p",[v._v("数据库"),n("strong",[v._v("概念")]),v._v("设计的目标：定义和描述应用领域设计的"),n("strong",[v._v("数据范围")]),v._v("；获取应用领域或问题域的信息模型；描述清楚数据的属性特征；描述清楚数据之间的关系；定义和描述数据的约束；说明数据的"),n("strong",[v._v("安全性要求")]),v._v("；支持用户的各种数据处理需求；保证信息模型方便地转换成数据的逻辑结构（数据库模式），同时也便于用户理解。")]),v._v(" "),n("p",[v._v("对实体集命名，在标识实体集的基础上分类抽象，将具有相同属性特征的同类对象抽象为实体集，然后归纳整理，用一个有意义的名词式各词短语为每一个"),n("strong",[v._v("实体")]),v._v("命名。")]),v._v(" "),n("p",[v._v("列值为空（"),n("strong",[v._v("NOT NULL")]),v._v("）\n列值唯一（"),n("strong",[v._v("NUIQUE")]),v._v("）\n布尔表达式（"),n("strong",[v._v("CHECK")]),v._v("）")]),v._v(" "),n("p",[v._v("在新建数据库应用系统中加载数据属于数据库应用系统{"),n("strong",[v._v("实现与部署")]),v._v("}阶段的任务。")]),v._v(" "),n("h3",{attrs:{id:"实现与部署内容包括"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现与部署内容包括"}},[v._v("#")]),v._v(" "),n("strong",[v._v("实现与部署")]),v._v("内容包括：")]),v._v(" "),n("ol",[n("li",[v._v("建立数据库结构。")]),v._v(" "),n("li",[v._v("数据加载。")]),v._v(" "),n("li",[v._v("事务和应用程序的编码及测试。（"),n("strong",[v._v("事务详细编码设计")]),v._v("）")]),v._v(" "),n("li",[v._v("系统集成、测试与试运行。")]),v._v(" "),n("li",[v._v("系统部署。")])]),v._v(" "),n("h3",{attrs:{id:"模型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#模型"}},[v._v("#")]),v._v(" "),n("strong",[v._v("模型")]),v._v("：")]),v._v(" "),n("p",[v._v("瀑布模型：基于"),n("strong",[v._v("严格的、明确")]),v._v("的需求。\n快速原型模型：是一种快速开发方法。\n螺旋模型：将"),n("strong",[v._v("瀑布")]),v._v("模型的系统化与快速模型的可修改性结合起来，引入风险评估活动")]),v._v(" "),n("p",[n("strong",[v._v("系统规划和定义")]),v._v("的具体内容包括：任务陈述、确定任务"),n("strong",[v._v("目标")]),v._v("、确定"),n("strong",[v._v("系统")]),v._v("范围和"),n("strong",[v._v("边界")]),v._v("、确定用户"),n("strong",[v._v("视图")]),v._v("。")]),v._v(" "),n("p",[n("strong",[v._v("需求分析")]),v._v("：\n"),n("strong",[v._v("数据")]),v._v("需求分析。\n"),n("strong",[v._v("功能")]),v._v("需求分析（数据处理需求分析、业务规划需求分析）\n"),n("strong",[v._v("性能")]),v._v("需求分析（数据操作响应时间或数据访问响应时间、系统吞吐量允许并发访问的最大用户数、每秒 TPS 代价值）\n其他需求分析（存储需求分析、安全性需求分析、备份和恢复需求分析）")]),v._v(" "),n("p",[v._v("3 个实体 和 1 个多对多，则得到 4 个关系模式。")]),v._v(" "),n("p",[v._v("数据库"),n("strong",[v._v("性能优化")]),v._v("：数据库运行环境、数据库参数调整、"),n("strong",[v._v("模式")]),v._v("调整（对表进行规范化以减少更新操作的代价）、数据库"),n("strong",[v._v("存储")]),v._v("优化和"),n("strong",[v._v("查询")]),v._v("优化（删除那些基数比较小的列上的索引以减少维护开销）。")]),v._v(" "),n("p",[n("strong",[v._v("事务规范")]),v._v("包括了事务名称、事务描述，事务所访问的数据项、事务用户。")]),v._v(" "),n("p",[n("strong",[v._v("日常维护")]),v._v("包括了：备份与恢复、完整性维护、安全性维护、存储空间管理和并发控制。")]),v._v(" "),n("p",[n("strong",[v._v("操作可行性研究")]),v._v("是论证是否具备 DBAS 开发所需的各类人员资源（项目管理人员、数据库系统分析员、应用编程人员等）、软件资源、硬件资源和工作环境。")]),v._v(" "),n("p",[v._v("应用系统日常维护：备份与恢复、完整性维护、安全性维护存储空间管理和"),n("strong",[v._v("并发控制")]),v._v("。")]),v._v(" "),n("h3",{attrs:{id:"项目规划"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#项目规划"}},[v._v("#")]),v._v(" "),n("strong",[v._v("项目规划")]),v._v("：")]),v._v(" "),n("ol",[n("li",[v._v("确定项目的"),n("strong",[v._v("目标")]),v._v("和范围，根据系统规划与定义的工作内容，具体说明项目的最终产品以及期望的时间、成本和质量目标。")]),v._v(" "),n("li",[v._v("根据 DBAS 软件开发模型，分解和定义整个项目包括的工作活动和任务。")]),v._v(" "),n("li",[v._v("估算完成该项目的规模及所需各种资源。")]),v._v(" "),n("li",[v._v("制定合理的 DBAS 项目计划、包括"),n("strong",[v._v("进度、成本、质量")]),v._v("等方面的预测。")])]),v._v(" "),n("h2",{attrs:{id:"第二章需求分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#第二章需求分析"}},[v._v("#")]),v._v(" 第二章需求分析")]),v._v(" "),n("p",[v._v("DFD（数据流图）")]),v._v(" "),n("p",[v._v("需求分析过程包括"),n("strong",[v._v("标识问题、建立需求、描述需求、确认需求")]),v._v("。")]),v._v(" "),n("p",[v._v("DFD 和 IDEFO 可用于建立需求模型。")]),v._v(" "),n("p",[v._v("常用的需求建模方法包括\n"),n("strong",[v._v("DFD 方法")]),v._v(" "),n("strong",[v._v("IDEFO 方法")]),v._v(" "),n("strong",[v._v("UML 方法")])]),v._v(" "),n("p",[v._v("DFD 建模方法属于"),n("strong",[v._v("结构化分析方法。")])]),v._v(" "),n("p",[v._v("DFD 图采用自顶向下逐步细化的结构化分析方法。")]),v._v(" "),n("p",[n("strong",[v._v("矩形框")]),v._v("来表示的元素是"),n("strong",[v._v("处理")]),v._v("。\n"),n("strong",[v._v("数据流")]),v._v("用"),n("strong",[v._v("箭头")]),v._v("表示。\n"),n("strong",[v._v("数据存储")]),v._v("用"),n("strong",[v._v("圆角矩形框")]),v._v("表示。\n"),n("strong",[v._v("外部项")]),v._v("用"),n("strong",[v._v("圆角框")]),v._v("或者"),n("strong",[v._v("平行四边形框。")]),v._v("\nIDEFO 需求建模方法中：\n矩形框的\n"),n("strong",[v._v("左侧")]),v._v("表示输入。\n"),n("strong",[v._v("右侧")]),v._v("表示输出。\n"),n("strong",[v._v("上方")]),v._v("表示控制：执行的"),n("strong",[v._v("事件")]),v._v("或约束条件。\n"),n("strong",[v._v("下方")]),v._v("表示机制：实施的"),n("strong",[v._v("物理手段")]),v._v("或所需要的资源。（计算机系统、人或组织）")]),v._v(" "),n("p",[v._v("数据库系统设计分为 6 个阶段："),n("strong",[v._v("需求分析、概念结构设计、逻辑结构设计和物理结构设计。")])]),v._v(" "),n("p",[v._v("应用题：\nDFD 方法由四种基本元素构成，他们是"),n("strong",[v._v("数据流、处理、数据存储、外部项。")])]),v._v(" "),n("p",[v._v("IDEFO 需求建模方法由"),n("strong",[v._v("箭头")]),v._v("和"),n("strong",[v._v("活动")]),v._v("或方框或矩形框两种元素构成。")]),v._v(" "),n("p",[n("strong",[v._v("外部实体")]),v._v("指系统之外又和系统有联系的人或者事物，说明了数据的"),n("strong",[v._v("外部")]),v._v("来源和"),n("strong",[v._v("去处")]),v._v("。\n"),n("strong",[v._v("处理")]),v._v("指对数据逻辑处理，也就是数据变换，它用来改变数据值。\n"),n("strong",[v._v("数据流")]),v._v("是指处理功能的输入输出数据存储表示数据保存的地方，他用来"),n("strong",[v._v("存储")]),v._v("数据。")]),v._v(" "),n("p",[v._v("DFD 建模方法的"),n("strong",[v._v("核心")]),v._v("是"),n("strong",[v._v("数据流")]),v._v("。\nDFD 的"),n("strong",[v._v("箭头")]),v._v("表示的数据的"),n("strong",[v._v("流向")]),v._v("。\n数据库物理设计的目的是将数据的逻辑描述转换为实现技术规范，其目的是设计数据存储方案，以便提供足够好的性能并确保数据库数据的完整性、安全性和可恢复性。")]),v._v(" "),n("h2",{attrs:{id:"第三章-数据库结构设计"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#第三章-数据库结构设计"}},[v._v("#")]),v._v(" 第三章 数据库结构设计")]),v._v(" "),n("p",[v._v("函数依赖的定义为：设 R（U）是属性集 U 上的关系模型 X，Y 是 U 的子集，若对于 R（U）的任意一个可能的关系 r，r 中不可能存在两个元组在 X 上属性值相等，而在 Y 上的属性值不等，则称 X 函数确定 Y 或 Y 函数依赖于 X。")]),v._v(" "),n("p",[v._v("对模式进行分解时，既要保证分解具有“无损连接性”，又要保证分解“保持函数依赖”。所谓“"),n("strong",[v._v("无损连接")]),v._v("”指分解的若干连接重组时可以精确回复到原来的数据表，数据记录既没有增加也没有减少。 F={A->D,B->D,C->D}分解成 R1（A,B,C）和 R2{C,D}。其中 ABC 是主码，D 为非主属性，D 依赖于 ABC 分解可恢复原关系，但其中隐含的 D 对 A,B 的依赖缺丢失了。则不保持函数依赖。")]),v._v(" "),n("p",[v._v("3NF 属于 2NF 属于 1NF，要满足第二范式要先满足第一范式。")]),v._v(" "),n("p",[n("strong",[v._v("关系模式的设计")]),v._v("、"),n("strong",[v._v("规范化处理")]),v._v("属于数据库逻辑结构设计的内容。")]),v._v(" "),n("p",[v._v("第一范式：每个属性不可再分。\n第二范式："),n("strong",[v._v("不允许")]),v._v("存在部分函数依赖。\n第三范式：是二范式基础上，不允许存在传递函数依赖。")]),v._v(" "),n("p",[n("strong",[v._v("规范化程度解释：")]),v._v("\nS➡D，D➡M，可以推出 S➡M；所以存在传递依赖；\n第三范式规定不存在函数依赖，所以不满足第三范式；\n属性不可再分，满足第一范式；\n第一范式基础上，不存在部分函数依赖，所以满足第二范式，即 2NF；\n你可能对部分函数依赖不理解，我解释一下：S➡D，意味着 D 依赖于 S，也就是 S 的内容决定着 D 的内容；如果{A,B}➡M,同时有 B➡M，那就有部分函数依赖了，因为{A,B}中的一个子集是 B，B 是集合中的一部分；这就是部分函数依赖")]),v._v(" "),n("p",[n("strong",[v._v("分解")]),v._v("一般情况下可以减少部分数据冗余，但不恰当的分解也可能增加冗余。")]),v._v(" "),n("p",[v._v("仅具有登录权限的用户只能对 master、msdb 数据库部分数据进行查询。")]),v._v(" "),n("p",[v._v("关系数据库中的视图提供了{"),n("strong",[v._v("逻辑")]),v._v("}数据独立性。\n比如重构数据库时，将一个基本表分成多个基本表，尽管数据库的逻辑结构改变了，但应用程序不必修改，因为新建立的视图定义为用户原来的关系，使用户的外模式保持不变，用户的应用程序通过视图仍然能够查找数据。")]),v._v(" "),n("p",[n("strong",[v._v("视图")]),v._v("是"),n("strong",[v._v("外模式")]),v._v("的实现方式之一。")]),v._v(" "),n("p",[n("strong",[v._v("数据模型三个要素")]),v._v("：\n数据结构：表述了"),n("strong",[v._v("客观世界")]),v._v("中数据对象本身的结构和数据对象之间的关联关系，是 Udine 系统"),n("strong",[v._v("静态")]),v._v("特征的描述。\n数据操作：主要指检索和更新（插入、删除、修改）两类操作。数据操作是对系统"),n("strong",[v._v("动态")]),v._v("特征的描述。\n数据完整性约束：规定数据库状态及状态变化所应满足的条件，以保证数据的正确性、有效性和相容性。")]),v._v(" "),n("p",[v._v("关系数据中要求关系的主码不能为空，这属于数据模型三要素中的{"),n("strong",[v._v("完整性约束")]),v._v("}。")]),v._v(" "),n("p",[v._v("设有关系模式 R{A,B,C,D}，存在函数依赖集：{A->B,C->D}则 R 最高可属于{1NF}。\nR 中（A,C）->（B,D）存在非主属性对主码二部分函数依赖，故不满足 2NF。")]),v._v(" "),n("p",[n("strong",[v._v("概念")]),v._v("设计："),n("strong",[v._v("设计 ER 图")]),v._v("。")]),v._v(" "),n("p",[n("strong",[v._v("逻辑")]),v._v("设计："),n("strong",[v._v("ER")]),v._v(" 图到"),n("strong",[v._v("关系")]),v._v("模式的转换和定义数据的"),n("strong",[v._v("约束")]),v._v("条件。")]),v._v(" "),n("p",[v._v("数据库"),n("strong",[v._v("物理设计")]),v._v("阶段活动包括：")]),v._v(" "),n("ol",[n("li",[v._v("数据库逻辑模式调整；")]),v._v(" "),n("li",[v._v("选择或配置基本关系表的"),n("strong",[v._v("文件组织形式")]),v._v("，为基本关系表设计数据存取方法或存取路径；（"),n("strong",[v._v("有关表的都是物理操作，事务。")]),v._v("）\n（"),n("strong",[v._v("关系属于逻辑、规范化处理、约束")]),v._v("）")]),v._v(" "),n("li",[v._v("数据分布设计；")]),v._v(" "),n("li",[v._v("安全模式设计；")]),v._v(" "),n("li",[v._v("确定系统配置；")]),v._v(" "),n("li",[v._v("物理模式评估；\n（"),n("strong",[v._v("设置存储分配参数、创建必要的索引、确定数据库和操作系统参数")]),v._v("）\n物理设计并不包括文件和数据库的具体实现细节（例如如何创建文件、建立数据库以及如何加载数据等）")])]),v._v(" "),n("p",[v._v("ORDER BY（order by）：视图中可以视同 ORDER BY，"),n("strong",[v._v("子查询")]),v._v("语句是"),n("strong",[v._v("不能")]),v._v("使用 ORDER BY 字句的。")]),v._v(" "),n("p",[n("strong",[v._v("关系")]),v._v("级别约束："),n("strong",[v._v("FOREIGN KEY")]),v._v(" 和"),n("strong",[v._v("PRIMARY KEY")]),v._v("。\n"),n("strong",[v._v("列")]),v._v("级约束：NOT NULL（不能为空） UNIQUE。\n"),n("strong",[v._v("元组")]),v._v("约束：CHECK。")]),v._v(" "),n("h3",{attrs:{id:"索引"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#索引"}},[v._v("#")]),v._v(" 索引")]),v._v(" "),n("p",[n("strong",[v._v("稀疏索引")]),v._v("是指如果只是"),n("strong",[v._v("一部分")]),v._v("查找码的值有对应的索引记录，则该索引为稀疏索引。\n"),n("strong",[v._v("稠密索引")]),v._v("是指如果数据文件中的"),n("strong",[v._v("每一个")]),v._v("查找码值在索引文件中都"),n("strong",[v._v("对应一个")]),v._v("索引记录，则该索引为稠密索引。")]),v._v(" "),n("p",[v._v("SQL Server 中根据索引的实现方式，索引技术可以分成有序索引和{"),n("strong",[v._v("散列索引")]),v._v("}两大类。")]),v._v(" "),n("p",[v._v("有序："),n("strong",[v._v("稠密")]),v._v("索引和"),n("strong",[v._v("稀疏")]),v._v("索引")]),v._v(" "),n("p",[v._v("如果数据文件中的每个查找码值在索引文件中都对应一个索引记录，则称该索引为{"),n("strong",[v._v("稠密")]),v._v("}索引，")]),v._v(" "),n("p",[v._v("如果索引文件只包含数据文件中的部分查找码，则称该索引为{"),n("strong",[v._v("稀疏")]),v._v("}索引。")]),v._v(" "),n("p",[v._v("如果数据文件中的数据记录的排列顺序与索引文件中索引项的排列顺序相一致。则该索引文件称为{"),n("strong",[v._v("聚集")]),v._v("}索引。")]),v._v(" "),n("p",[n("strong",[v._v("聚集文件")]),v._v("：不同关系表中有关联关系的记录存储在一起。可以提高"),n("strong",[v._v("频繁")]),v._v("进行多表连接操作的查询效率。")]),v._v(" "),n("p",[n("strong",[v._v("散列索引")]),v._v("：只适用于查询某"),n("strong",[v._v("一个特定值")]),v._v("的情况，只适合"),n("strong",[v._v("点查询")]),v._v("。")]),v._v(" "),n("p",[n("strong",[v._v("散列文件")]),v._v("：利用散列存储方式组织的文件，亦称为直接存取文件。\n散列文件的"),n("strong",[v._v("优点")]),v._v("是：文件"),n("strong",[v._v("随机")]),v._v("存放，记录"),n("strong",[v._v("不需进行排序")]),v._v("；插入、删除"),n("strong",[v._v("方便")]),v._v("；存取速度"),n("strong",[v._v("快")]),v._v("；"),n("strong",[v._v("不需要索引区")]),v._v("，节省存储空间。")]),v._v(" "),n("p",[v._v("其缺点是："),n("strong",[v._v("不能进行顺序存取")]),v._v("，只能按"),n("strong",[v._v("关键字")]),v._v("随机存取，且询问方式只限于简单询问，并且在经过多次插入、删除后，也可能造成"),n("strong",[v._v("文件结构不合理")]),v._v("，需要重新"),n("strong",[v._v("组织")]),v._v("文件。")]),v._v(" "),n("p",[v._v("顺序文件：文件信息存放若干连续的物理块中。其优点是简单，支持"),n("strong",[v._v("顺序")]),v._v("存取和"),n("strong",[v._v("随机")]),v._v("存取，顺序存取速度相对较快。\n缺点是：文件"),n("strong",[v._v("不能动态")]),v._v("增长，不利于文件插入和删除。如果用户的查询条件定义在查找码上，则顺序文件是比较适合的文件结构。")]),v._v(" "),n("p",[n("strong",[v._v("聚集索引")]),v._v("是指数据库表行中数据的物理顺序与键值的逻辑（索引）顺序相同。一个表只能有"),n("strong",[v._v("一个聚集索引")]),v._v("，因为一个表的物理顺序只有一种情况，所以对应的聚集索引只能有一个。一个表中可以有"),n("strong",[v._v("多个唯一索引")]),v._v("，唯一索引的作用是保证索引键的值不重复，能极大地提高查询速度，而且还有唯一约束的作用。"),n("strong",[v._v("唯一索引可以是聚集索引")]),v._v("。")]),v._v(" "),n("p",[v._v("在数据文件的主码属性集上建立的索引称为"),n("strong",[v._v("主索引")]),v._v("。Crete unique clustered index idx1 on R(A)中 "),n("strong",[v._v("unique")]),v._v(" 表示为表建立"),n("strong",[v._v("唯一索引")]),v._v("；"),n("strong",[v._v("clustered")]),v._v(" 表示为表创建"),n("strong",[v._v("聚集索引")]),v._v("。根据题干不能确定列 A 是主码列，因此不能确定是不是主索引。")]),v._v(" "),n("p",[n("strong",[v._v("主索引一定是唯一索引，不一定是聚集索引")]),v._v("。")]),v._v(" "),n("p",[v._v("如果数据文件中数据记录的"),n("strong",[v._v("排列顺序")]),v._v("与索引文件中索引项的"),n("strong",[v._v("排列顺序相一致")]),v._v("，或者说，索引文件按照其查找码"),n("strong",[v._v("指定的顺序")]),v._v("与数据文件中"),n("strong",[v._v("数据记录")]),v._v("的"),n("strong",[v._v("排列顺序相一致")]),v._v("，则该索引文件称为"),n("strong",[v._v("聚集索引")]),v._v("。否则为非聚集索引。")]),v._v(" "),n("p",[n("strong",[v._v("聚集索引的键值可以重复")]),v._v("。")]),v._v(" "),n("h3",{attrs:{id:"优化-sql"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#优化-sql"}},[v._v("#")]),v._v(" 优化 SQL")]),v._v(" "),n("p",[n("strong",[v._v("优化 SQL")]),v._v(" 语句执行效率方法的是：")]),v._v(" "),n("ol",[n("li",[v._v("利用"),n("strong",[v._v("存储过程")]),v._v("封装频繁使用的 SQL 语句。")]),v._v(" "),n("li",[v._v("不要随意使用"),n("strong",[v._v("游标")]),v._v("。")]),v._v(" "),n("li",[v._v("合理使用相关"),n("strong",[v._v("子查询")]),v._v("。")])]),v._v(" "),n("p",[v._v("如果一个表的数据量很少，并且对其"),n("strong",[v._v("修改操作频繁")]),v._v("，则该表最适合采用的文件组织结构是{"),n("strong",[v._v("堆文件")]),v._v("}。")]),v._v(" "),n("p",[v._v("常见能提高连接操作性能或者减少连接操作的是：\n"),n("strong",[v._v("增加冗余列")]),v._v("：指在多个表中增加具体相同语义的列，它常用来在查询是避免连接操作；\n"),n("strong",[v._v("反规范化")]),v._v("：也就是降低表的规范化程度，减少表间的链接，提高查询性能；\n"),n("strong",[v._v("相关列建立索引")]),v._v("：对于经常需要进行查询、链接、统计操作，且数据量大的基本表可以建立索引提高查询效率。\n"),n("strong",[v._v("聚集文件")]),v._v("：可以提高频繁进行多表连接操作的查询效率。")]),v._v(" "),n("p",[v._v("提高事务"),n("strong",[v._v("吞吐量")]),v._v("：将大事务"),n("strong",[v._v("分解")]),v._v("成小事务，避免死锁，将单一磁盘改为 "),n("strong",[v._v("RAID1")]),v._v(" 磁盘存储系统费，使用行级锁。")]),v._v(" "),n("p",[v._v("在衡量数据库应用系统的性能指标中，{"),n("strong",[v._v("数据吞吐量")]),v._v("}指的是系统在单位时间内可以完成的数据库事务数量。")]),v._v(" "),n("p",[v._v("对 SQL 语句进行性能调优属于数据库应用系统{"),n("strong",[v._v("运行管理与维护")]),v._v("}阶段的任务。")]),v._v(" "),n("h3",{attrs:{id:"建模联系"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#建模联系"}},[v._v("#")]),v._v(" 建模联系")]),v._v(" "),n("p",[v._v("在 IDED1X 数据建模方法中，如果一个实体集的"),n("strong",[v._v("唯一标识")]),v._v("有赖于该"),n("strong",[v._v("实体集与其他实体集")]),v._v("的联系，则称这种类型的实体集为从属实体集。")]),v._v(" "),n("p",[v._v("在 IDEF1X 数据建模方法中，"),n("strong",[v._v("直角")]),v._v("矩形框用于表示"),n("strong",[v._v("独立实体")]),v._v("集，"),n("strong",[v._v("圆角矩形框")]),v._v("用于表示"),n("strong",[v._v("从属")]),v._v("实体集")]),v._v(" "),n("p",[n("strong",[v._v("IDEF1X 建模")]),v._v("方法："),n("strong",[v._v("实体")]),v._v("集（独立实体集、从属实体集）、"),n("strong",[v._v("联系")]),v._v("（标定型联系、非标定型联系、分类联系、非确定联系）。"),n("strong",[v._v("从属")]),v._v("实体集可以有自己的"),n("strong",[v._v("主码")]),v._v("。")]),v._v(" "),n("p",[v._v("在 IDEF1X 数据建模方法中，多对多联系又被称作{"),n("strong",[v._v("非确定")]),v._v("}联系。")]),v._v(" "),n("p",[v._v("一对多："),n("strong",[v._v("标定")]),v._v("型联系")]),v._v(" "),n("p",[v._v("在“"),n("strong",[v._v("确定型")]),v._v("连接联系”中，如果子女实体集的每个实例都是由它与双亲的联系而确定，那么这个联系就被称为“"),n("strong",[v._v("标定型")]),v._v("联系”。\n在标定型联系中子女实体集总是从属实体集，标定型联系用一条实线或者线段把它们连接起来，")]),v._v(" "),n("p",[v._v("标定型联系："),n("strong",[v._v("直线")]),v._v("，用"),n("strong",[v._v("圆角矩形框")]),v._v("。\n非标定型联系："),n("strong",[v._v("虚线")]),v._v("。")]),v._v(" "),n("h3",{attrs:{id:"模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#模式"}},[v._v("#")]),v._v(" 模式")]),v._v(" "),n("p",[n("strong",[v._v("内模式")]),v._v("又称"),n("strong",[v._v("物理模式")]),v._v("，处于"),n("strong",[v._v("最底层")]),v._v("，它给出了数据库存储结构和物理存取方式，内模式反映了数据在计算机物理结构中的实际存储形式，"),n("strong",[v._v("一个数据库只对应一种内模式")]),v._v("。")]),v._v(" "),n("p",[n("strong",[v._v("外模式")]),v._v("的是用户的局部模式，"),n("strong",[v._v("一个数据库中可以定义多个外模式")]),v._v("。")]),v._v(" "),n("p",[n("strong",[v._v("数据独立性")]),v._v("不仅简化数据库应用程序的开发，同时因为屏蔽了物理结构的差异，所有也"),n("strong",[v._v("简化")]),v._v("了用户维护数据的代价。")]),v._v(" "),n("p",[v._v("数据库系统三级模式和两层映像的系统结构保证了数据库系统中能够具有较高的逻辑独立性和物理独立性。")]),v._v(" "),n("p",[n("strong",[v._v("外模式")]),v._v("可以有多个，其是应用程序或用户与数据库通信的借口"),n("strong",[v._v("不用的用户访问同一个数据库对应多个外模式")]),v._v("。")]),v._v(" "),n("p",[v._v("数据与程序之间的独立性，使数据定义与描述分离，所有数据的存取由 DBMS 管理，用户不必考虑存取细节，所有减少了应用程序的维护。")]),v._v(" "),n("p",[n("strong",[v._v("事务概要设计")]),v._v("内容包括："),n("strong",[v._v("事务名称、事务所访问的关系表及关系属性、事务处理逻辑、事务用户")]),v._v("（指使用、启动、调用该事务的软件模块或系统）。")]),v._v(" "),n("p",[v._v("数据库的"),n("strong",[v._v("反规范化")]),v._v("是为了"),n("strong",[v._v("减少")]),v._v("表间的"),n("strong",[v._v("连接")]),v._v("，提高查询性能，但并非所有经反规范化的数据库都是高效的，这与实际的应用有关，只有满足一定条件的数据库采用反规范化才能提高性能。")]),v._v(" "),n("p",[n("strong",[v._v("候选码")]),v._v("："),n("strong",[v._v("不能")]),v._v("有"),n("strong",[v._v("重复")]),v._v("也不能为空。")]),v._v(" "),n("p",[v._v("第四章：数据库应用系统功能设计与实施")]),v._v(" "),n("p",[v._v("数据库应用系统设计的四个层次分别为：\n"),n("strong",[v._v("表示层")]),v._v("：用于显示数据和接受用户输入的数据。（一般为 Windows 应用程序或 Web 应用程序）\n"),n("strong",[v._v("业务逻辑层")]),v._v("：是表示层和数据访问层之间的桥梁，主要负责数据的传递和处理。梳理 DBAS 的各项业务活动，将其表示为各种系统"),n("strong",[v._v("构件")]),v._v("（如类、模块、组件），\n（"),n("strong",[v._v("存储过程设计")]),v._v("）\n"),n("strong",[v._v("数据访问层")]),v._v("：实现对数据的"),n("strong",[v._v("保存和读取")]),v._v("操作。可以访问关系数据库、文本文件和 XML 文档等。（进行"),n("strong",[v._v("事务设计")]),v._v("），进行"),n("strong",[v._v("获取")]),v._v("就是访问层。负责与 DBMS 系统进行交互，"),n("strong",[v._v("提取")]),v._v("或存入应用系统所需的数据。使用"),n("strong",[v._v("create procedure")]),v._v("命令所定义的存储过程位于访问层。\n"),n("strong",[v._v("数据持久层")]),v._v("：以程序为媒介把表现层或服务层的数据持久化，它位于物理层和数据访问层之间。（"),n("strong",[v._v("索引设计、完整性维护工作")]),v._v("），负责保存和管理应用系统数据。主要任务是应用系统的"),n("strong",[v._v("存储结构")]),v._v("设计。")]),v._v(" "),n("p",[n("strong",[v._v("业务逻辑层概要设计")]),v._v("的原则主要体现在以下几个方面：")]),v._v(" "),n("ol",[n("li",[v._v("构建本身应由相关性很强的代码组成，一个构件或一个模块只负责完成一项任务，也就是常说的"),n("strong",[v._v("单一责任")]),v._v("原则。")]),v._v(" "),n("li",[v._v("组成系统业务逻辑层的各个构件应具备独立的功能，并且最大限度地减少与其他构件功能重叠。")]),v._v(" "),n("li",[v._v("构建之间的接口应尽量简单明确。")]),v._v(" "),n("li",[v._v("如果某两个构件间的关系比较复杂，应考虑进一步进行模块划分。")]),v._v(" "),n("li",[v._v("如果构件过于复杂，可以将其细分。")])]),v._v(" "),n("p",[n("strong",[v._v("降低事务隔离级别")]),v._v("可以"),n("strong",[v._v("提高事务的吞吐量")]),v._v("，"),n("strong",[v._v("提高活锁的可能性，降低发生死锁")]),v._v("，发生阻塞的可能性。")]),v._v(" "),n("p",[n("strong",[v._v("预防死锁")]),v._v("：\n各个事务"),n("strong",[v._v("顺序")]),v._v("访问资源，大事务分解成小的事务。\n按"),n("strong",[v._v("同一顺序")]),v._v("访问对象。\n"),n("strong",[v._v("降低事务")]),v._v("隔离性级别。\n使用"),n("strong",[v._v("绑定连接")]),v._v("。\n使用行级锁。")]),v._v(" "),n("p",[n("strong",[v._v("提高")]),v._v("事务的"),n("strong",[v._v("隔离性级")]),v._v("别带来的"),n("strong",[v._v("好处")]),v._v("是降低了发生数据"),n("strong",[v._v("不一致")]),v._v("的可能性。")]),v._v(" "),n("p",[v._v("每个事务的执行程序划分两个阶段，加锁阶段和解锁阶段。")]),v._v(" "),n("p",[n("strong",[v._v("加锁")]),v._v("阶段事务"),n("strong",[v._v("可以申请")]),v._v("获得任何数据项上的任何类型的所，但是"),n("strong",[v._v("不允许释放")]),v._v("任何锁。\n在解锁阶段，事务可以释放在任何数据项上任何类型的锁，但是"),n("strong",[v._v("不能再申请")]),v._v("任何锁。")]),v._v(" "),n("p",[v._v("每个事务开始执行后就进入了加锁阶段。\n能减少死锁的方法：\n各个事务应顺序访问共享资源，将复杂的、大的事务"),n("strong",[v._v("分解")]),v._v("成多个简单、小的事务。\n按"),n("strong",[v._v("同一顺序")]),v._v("访问对象。\n"),n("strong",[v._v("事务隔离性级别")]),v._v("。\n使用"),n("strong",[v._v("绑定")]),v._v("连接。\n灵活使用显示加锁技术等。")]),v._v(" "),n("h3",{attrs:{id:"三层结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三层结构"}},[v._v("#")]),v._v(" 三层结构")]),v._v(" "),n("p",[v._v("在 "),n("strong",[v._v("C/S")]),v._v(" 结构中，客户端属于“"),n("strong",[v._v("胖")]),v._v("客户端”；\n在 "),n("strong",[v._v("B/S")]),v._v(" 结构中，客户端属于“"),n("strong",[v._v("瘦")]),v._v("客户端”。\n"),n("strong",[v._v("二层 C/S")]),v._v(" 结构中，应用业务规则主要是在"),n("strong",[v._v("客户端")]),v._v("实现的。\n"),n("strong",[v._v("三层 B/S")]),v._v(" 结构中，应用业务规则主要是在 "),n("strong",[v._v("WEB")]),v._v(" 服务器端实现的，一部分事务逻辑在前端实现，主要的业务逻辑在服务器实现，所以对客户机配置要求不高，使对服务器要求较高，也不需要安装客户端软件。"),n("strong",[v._v("只需安装 WEB 游览器")]),v._v("即可。\n在运行速度、数据安全、人机交互等方面，B/S 不如 C/S。")]),v._v(" "),n("p",[v._v("三层浏览器、服务器结构的数据库应用系统是由"),n("strong",[v._v("游览器")]),v._v("、{"),n("strong",[v._v("数据库")]),v._v("}服务器和"),n("strong",[v._v("应用")]),v._v("服务器三部分组成的。")]),v._v(" "),n("p",[v._v("在三层 B/S 结构的数据库应用系统中，"),n("strong",[v._v("事务")]),v._v("处理是在{"),n("strong",[v._v("数据库")]),v._v("}服务器端完成的")]),v._v(" "),n("p",[v._v("在三层 B/S 结构的数据库应用系统中，业务规则是在{"),n("strong",[v._v("应用")]),v._v("}服务器端完成的。")]),v._v(" "),n("p",[v._v("关系表在逻辑上由一系列"),n("strong",[v._v("元组")]),v._v("组成，元组由"),n("strong",[v._v("多个属性")]),v._v("组成，每个元组可以用数据库磁盘文件中的一个逻辑记录来存储，记录包括多个域。元组的每个属性对应文件记录中的一个"),n("strong",[v._v("域")]),v._v("。")]),v._v(" "),n("p",[v._v("数据库完整性约束条件的作用对象分为：列、元组和{"),n("strong",[v._v("关系")]),v._v("}三种级别")]),v._v(" "),n("h3",{attrs:{id:"dbms"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dbms"}},[v._v("#")]),v._v(" DBMS")]),v._v(" "),n("p",[n("strong",[v._v("DBMS 不会")]),v._v("检查数据完整性"),n("strong",[v._v("约束")]),v._v("。")]),v._v(" "),n("p",[v._v("数据库管理系统为用户和应用程序提供了{"),n("strong",[v._v("DDL")]),v._v("}语言。")]),v._v(" "),n("p",[v._v("数据库应用"),n("strong",[v._v("系统总体设计")]),v._v("的主要内容包括确定 "),n("strong",[v._v("DBAS 体系结构")]),v._v("、"),n("strong",[v._v("软硬件")]),v._v("选型、和"),n("strong",[v._v("配置")]),v._v("设计、应用"),n("strong",[v._v("软件总体")]),v._v("设计和业务"),n("strong",[v._v("规则")]),v._v("初步设计。")]),v._v(" "),n("p",[v._v("数据库应用系统的实施工作包括创建数据库、装载数据、编写与调试应用程序、数据库试运行。")]),v._v(" "),n("p",[v._v("在数据库事务{"),n("strong",[v._v("概要")]),v._v("}设计阶段，使用 read 和 write 原语来表达存取操作。")]),v._v(" "),n("p",[v._v("安全性保护相关的：用户身份鉴别、权限控制、视图机制。")]),v._v(" "),n("p",[v._v("人机界面先进行"),n("strong",[v._v("初步设计")]),v._v("，再进行用户界面细节设计，最后是原型设计与改进。（按顺序来，不能漏了）。")]),v._v(" "),n("h2",{attrs:{id:"第五章-uml-和数据库应用系统"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#第五章-uml-和数据库应用系统"}},[v._v("#")]),v._v(" 第五章 UML 和数据库应用系统")]),v._v(" "),n("p",[v._v("有关判断的部分要用菱形表示。\n"),n("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/619086901/619086901.github.io/databaseimg/UML.png",alt:""}}),v._v(" "),n("strong",[v._v("类")]),v._v("的 UML 表示（空心三角"),n("strong",[v._v("实线")]),v._v("连接）。子类对父类关系的继承。\n"),n("strong",[v._v("接口")]),v._v("的 UML 表示（空心三角"),n("strong",[v._v("虚线")]),v._v("连接）。接口与子类继承比较相似，区别主要在于多继承上。\n"),n("strong",[v._v("聚合")]),v._v("关系的 UML 表示（"),n("strong",[v._v("空心菱形")]),v._v("实线连接）。A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分。")]),v._v(" "),n("p",[v._v("在 UML 中，{"),n("strong",[v._v("聚集")]),v._v("}是一种特殊形式的关联，它表示类之间的关系是"),n("strong",[v._v("整体与部分")]),v._v("的关系。")]),v._v(" "),n("p",[n("strong",[v._v("合成")]),v._v("关系的 UML 表示（"),n("strong",[v._v("实心菱形")]),v._v("实线连接）。体现了严格的部分和整体关系。\n泛化：带三角箭头的"),n("strong",[v._v("实线")]),v._v("，箭头指向"),n("strong",[v._v("父类")]),v._v("。\n实现：带三角箭头的"),n("strong",[v._v("虚线")]),v._v("，箭头指向"),n("strong",[v._v("接口")]),v._v("。\n关联：带普通箭头的实心线，指向被拥有者。\n聚合：带"),n("strong",[v._v("空心")]),v._v("菱形的实心线，菱形指向整体。\n组合：带"),n("strong",[v._v("实心")]),v._v("菱形的实线，菱形指向整体。\n依赖：带箭头的虚线，指向被使用者。")]),v._v(" "),n("p",[v._v("结构图包括"),n("strong",[v._v("用例图、类图、组件图、对象图、部署图")]),v._v("。")]),v._v(" "),n("p",[v._v("设用 UML 设计某数据应用系统，设计人员规划了一组应用程序集，该集合由动态链接库和可执行程序构成。为了展现这些应用程序集间的"),n("strong",[v._v("组织")]),v._v("和依赖关系，以对源代码、可执行程序的发布等进行系统建模，应采用的 UML 图是{"),n("strong",[v._v("组件")]),v._v("}图。")]),v._v(" "),n("p",[v._v("组件图提供系统的物理视图。UML 图形中组件图的用途是显示系统中的软件对其他软件组件的依赖关系，它可以在一个非常高的层次上显示，从而仅显示粗粒度的组件，也可以在组件包层次上显示")]),v._v(" "),n("p",[v._v("AddNew：创建一条新记录。\nCancel，"),n("strong",[v._v("撤销")]),v._v("一次执行。\nClose：关闭一个 RecordSet。\nMoveNext：把纪录指针移动到下一条记录。")]),v._v(" "),n("p",[n("strong",[v._v("UML 一对多用(1:*)")]),v._v("，ER 图中一对多用 1：m 表示。")]),v._v(" "),n("p",[v._v("在 UML 中，"),n("strong",[v._v("用例")]),v._v("模型由例、系统和{"),n("strong",[v._v("角色")]),v._v("}三部分组成。")]),v._v(" "),n("p",[v._v("角色是系统进行交互的"),n("strong",[v._v("外部")]),v._v("实体，可以使系统用户也可以是其他系统或者硬件设备。")]),v._v(" "),n("p",[v._v("用例之间的关系包括扩展、使用和{"),n("strong",[v._v("组合")]),v._v("}三种。")]),v._v(" "),n("p",[v._v("用例模型通过对系统参与者及其重要行为的描述，表达系统的{"),n("strong",[v._v("功能")]),v._v("}需求，即用户的期望。")]),v._v(" "),n("p",[v._v("在 UML 提供的图中，{"),n("strong",[v._v("用例图")]),v._v("}用于描述系统与"),n("strong",[v._v("外部")]),v._v("系统及用户之间的"),n("strong",[v._v("交互")]),v._v("。")]),v._v(" "),n("p",[v._v("在 UML 中，用例用椭圆形表示，用例位于"),n("strong",[v._v("系统边界")]),v._v("的"),n("strong",[v._v("内部")]),v._v("。")]),v._v(" "),n("h3",{attrs:{id:"各种图"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#各种图"}},[v._v("#")]),v._v(" 各种图")]),v._v(" "),n("p",[n("strong",[v._v("类图")]),v._v("：展现一组类、接口和协作以及他们之间的关系的一种"),n("strong",[v._v("静态视图")]),v._v("。\n"),n("strong",[v._v("协作图（通信图）")]),v._v("：用于描述对象在空间中如何交互，即除了"),n("strong",[v._v("动态交互")]),v._v("，它也直接描述了对象如何链接在一起的情形，对象之间的联系以及"),n("strong",[v._v("对象间发送")]),v._v("和"),n("strong",[v._v("接受的消息")]),v._v("。")]),v._v(" "),n("p",[v._v("在 UML 模型中，用于表达一系列的对象、对象之间的联系以及对象间发送和接受消息的图是{"),n("strong",[v._v("通信图")]),v._v("}。")]),v._v(" "),n("p",[n("strong",[v._v("状态图")]),v._v("：主要用于描述一个对象在其生存期间的动态行为，表现为一个对象所经历的"),n("strong",[v._v("状态")]),v._v("序列，引起状态转移的事件，以及因状态转移而伴随的动作。一般可以用状态机对一个对象的生命周期建模，状态图用于显示状态机，重点在与描述状态图的控制流。")]),v._v(" "),n("p",[v._v("状态图中只能有"),n("strong",[v._v("一个起始")]),v._v("状态，可以有"),n("strong",[v._v("多个结束")]),v._v("状态。")]),v._v(" "),n("p",[n("strong",[v._v("顺序图")]),v._v("：主要用于描述指定的一组对象是如何交互的，它着眼于消息队列，顺序图是用来描述系统内部对象之间的消息发送和接受序列。")]),v._v(" "),n("p",[n("strong",[v._v("顺序图")]),v._v("：横向矩形框代表对象，水平消息线用于表示对象间的通信。")]),v._v(" "),n("p",[n("strong",[v._v("顺序图")]),v._v("可以用来描述对象的创建和销毁。创建或销毁一个对象的消息一般是"),n("strong",[v._v("同步")]),v._v("的。")]),v._v(" "),n("p",[v._v("顺序图有两个坐标轴，横向表示对象，纵向表示{"),n("strong",[v._v("时间")]),v._v("}的持续过程。")]),v._v(" "),n("p",[n("strong",[v._v("部署图")]),v._v("：描述的是系统运行时的"),n("strong",[v._v("结构")]),v._v("，展示了"),n("strong",[v._v("硬件的配置")]),v._v("及其软件如何部署到网络结构中。一个系统模型只有一个部署图，部署图通常用来帮助李杰分布式系统。")]),v._v(" "),n("p",[v._v("UML 图中，描述系统中硬件和软件的物理配置情况和系统体系结构的图称为{"),n("strong",[v._v("部署图")]),v._v("}。")]),v._v(" "),n("p",[n("strong",[v._v("活动图")]),v._v("：主要用于描述系统、用例和程序模块中逻辑流程的先后执行"),n("strong",[v._v("次序、并行次序")]),v._v("。")]),v._v(" "),n("p",[v._v("UML 中的{"),n("strong",[v._v("活动图")]),v._v("}述活动与活动之间流程控制的转移，其作用类似于流程图，然而与流程图不同的是其支持并行行为。")]),v._v(" "),n("p",[v._v("在 UML 中，当要描述状态之间的转换时，可通过{"),n("strong",[v._v("时间图")]),v._v("}来体现时间因子的作用")]),v._v(" "),n("p",[v._v("用于表达系统中不同的"),n("strong",[v._v("包")]),v._v("、命名空间或不同的项目间彼此关系的图称为{"),n("strong",[v._v("包图")]),v._v("}。")]),v._v(" "),n("p",[v._v("UML 的状态机图中，状态之间的转移是由{"),n("strong",[v._v("事件")]),v._v("}驱动的。")]),v._v(" "),n("p",[v._v("UML 的语义的四层建模概念框架分别是："),n("strong",[v._v("元元模型层、元模型层、模型层、用户模型层。")]),v._v("\n元元"),n("strong",[v._v("模型层")]),v._v("：最基本的元素“事物”，代表要定义的所有事物。\n元模型层：每个概念都是元元模型中的事物概念的实例。\n模型层：每个概念都是元模型层中概念的实例。\n用户模型层：每个概念都是模型层的一个实例。")]),v._v(" "),n("h2",{attrs:{id:"第六章"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#第六章"}},[v._v("#")]),v._v(" 第六章")]),v._v(" "),n("p",[v._v("小知识：有时只希望列出结果集中的前几行数据，而不是全部数据，就可以使用 TOP 谓词来限制输出的结果。")]),v._v(" "),n("h3",{attrs:{id:"谓词"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#谓词"}},[v._v("#")]),v._v(" 谓词")]),v._v(" "),n("p",[v._v("TOP "),n("strong",[v._v("谓词")]),v._v("的语法格式为：\nTOP n[percent][with ties]；")]),v._v(" "),n("ol",[n("li",[n("strong",[v._v("TOP n")]),v._v("：取查询结果的前 n 行数据；")]),v._v(" "),n("li",[n("strong",[v._v("TOP n percent")]),v._v("：取查询结果的前 n%行数据；")]),v._v(" "),n("li",[n("strong",[v._v("WITH TIES")]),v._v("：表示包括最后一行取值并列的结果")])]),v._v(" "),n("p",[v._v("TOP 3 放在*之前\n时间格式‘2015/1/1’")]),v._v(" "),n("p",[v._v("统计商品数量最多的前三类商品（包括并列情况），希望列出商品类别和商品数量。请补全下列语句：\nSELECT {"),n("strong",[v._v("TOP 3 WITH TIES")]),v._v("}商品类别，COUNT（"),n("em",[v._v("） AS 商品数量\nFROM 商品表\nGROUP BY 商品类别\nORDER BY COUNT（")]),v._v("）DESC")]),v._v(" "),n("p",[v._v("在 SQL Server 2008 中，使用 TOP 限制结果集时，如果需要获取查询结果的前 n%行数据则需要使用 TOP n {"),n("strong",[v._v("percent")]),v._v("}选项。")]),v._v(" "),n("p",[v._v("{"),n("strong",[v._v("UNION")]),v._v("}可以把两个或多个 SELECT 语句的查询结果"),n("strong",[v._v("组合")]),v._v("成一个结果集，使用时要求所有 SELECT 语句的列数应相同，对应列的数据类型相容。")]),v._v(" "),n("p",[v._v("在 T-SQL 中，实现查询结果差运算的运算符是{"),n("strong",[v._v("EXCEPT")]),v._v("}。")]),v._v(" "),n("p",[n("strong",[v._v("EXCEPT")]),v._v("：指在"),n("strong",[v._v("第一个集合中存在")]),v._v("，但是"),n("strong",[v._v("不存在于第二个")]),v._v("集合中的数据；")]),v._v(" "),n("p",[v._v("购买表（顾客号，商品号，购买时间），现要查询 C01 顾客购买过但 C02 顾客没有购买过的商品。请补全下列语句。\nSELECT 商品号 FROM 购买表 WHERE 顾客号=‘C01’\n{ "),n("strong",[v._v("EXCEPT")]),v._v(" }\nSELECT 商品号 FROM 购买表 WHERE 顾客号=‘cC02’")]),v._v(" "),n("p",[v._v("交操作 "),n("strong",[v._v("INTERSECT")])]),v._v(" "),n("p",[n("strong",[v._v("INTERSECT")]),v._v("，是指在两个集合中都存在的数据。")]),v._v(" "),n("p",[v._v("并操作 "),n("strong",[v._v("UNION")])]),v._v(" "),n("p",[n("strong",[v._v("UNION")]),v._v("：操作符用于合并两个或多个 SELECT 语句的结果集，对于 UNION 操作符，请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。")]),v._v(" "),n("p",[n("strong",[v._v("IN")]),v._v("：确定给定的值是否与子查询或列表中的值相匹配，选择与列表中的任意一个值匹配的行；")]),v._v(" "),n("h3",{attrs:{id:"函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[v._v("#")]),v._v(" 函数")]),v._v(" "),n("p",[v._v("范围划分明显有利于范围查询和点查询。"),n("strong",[v._v("数据比较少的采用复制")]),v._v("查询速度最快。")]),v._v(" "),n("p",[n("strong",[v._v("标量函数")]),v._v("的返回值可以使除了 "),n("strong",[v._v("timestamp")]),v._v(" 类型以外的所有数据类型。")]),v._v(" "),n("p",[v._v("能够出现在 SELECT 语句目标列中的用户自定义函数是{"),n("strong",[v._v("标量")]),v._v("}函数。")]),v._v(" "),n("p",[v._v("SQL Server 2008 支持三中用户"),n("strong",[v._v("自定义函数")]),v._v("：标量函数、内嵌表值函数和多语句表值函数。标量函数可以出现在 SELECT 语句目标列中，其他两个函数必须放在 SELECT 语句的 FROM 字句中。")]),v._v(" "),n("p",[v._v("标量函数中不适用 SET 语句。")]),v._v(" "),n("p",[v._v("设有课程表（课程号，课程名，开课学期）和选课表（学号，课程号，成绩），现要利用"),n("strong",[v._v("开窗函数")]),v._v("查询每门课程的课程名、开课学期及选该门课的学生人数（不包括没人选的课程）。请补全下列语句：\nSELECT DISTINCT 课程号，开课学期，COUNT（*）"),n("strong",[v._v("OVER")]),v._v("（{"),n("strong",[v._v("PARTITION")]),v._v("} BY T1.课程号）AS 选课人数 FROM 课程表 T1 JOIN 选课表 T2 ON T1.课程号=T2.课程号")]),v._v(" "),n("p",[v._v("SUM、AVG 以及 COUNT（*）可以称为开窗函数。\n开窗函数必须放在 "),n("strong",[v._v("OVER")]),v._v(" 子句"),n("strong",[v._v("前边")]),v._v("。")]),v._v(" "),n("p",[v._v("设有课程表（课程号，课程名，开课学期）和选课表（学号，课程号，成绩），现要定义一个用于查询每门课程的课程名、开课学期及选该门课的学生人数（不包括没人选的课程）的"),n("strong",[v._v("公用表表达式")]),v._v("。请补全下列语句：\n"),n("strong",[v._v("WITH")]),v._v(" CourseInfo（课程名，开课学期，选课人数）{"),n("strong",[v._v("AS")]),v._v("}（\nSELECT DISTINCT 课程名，开课学期，COUNT（*）OVER （PARTITION BY T1.课程号）AS 选课人数 FROM 课程表 T1 JOIN 选课表 T2 ON T1.课程号=T2.课程号）\n其语法格式：WITH "),n("strong",[v._v("公用表表达式")]),v._v(" 标识符（列表 1..列表 n）AS（select 语句）。")]),v._v(" "),n("p",[v._v("设有课程表（课程号，课程名，开课学期）和选课表（学号，课程号，成绩），现要定义一个用于查询每门课程的课程名、开课学期及选该门课的学生人数（不包括没人选的课程）的"),n("strong",[v._v("公用表表达式")]),v._v("。请补全下列语句：\n{"),n("strong",[v._v("WITH")]),v._v("} CourseInfo（课程名，开课学期，选课人数） AS（\nSELECT DISTINCT 课程名，开课学期，COUNT（*） OVER（PARTITION BY T1.课程号）AS 选课人数 FROM 课程表 T1 JOIN 选课表 T2 ON T1.课程号=T2.课程号）")]),v._v(" "),n("p",[v._v("设有商品表（商品号，商品名）和销售表（商品号，销售时间，销售数量），先要查询有多少种商品"),n("strong",[v._v("没有被卖出过")]),v._v("。请补全下列语句\nSELECT COUNT（*）FROM 商品表 LEFT JOIN 销售表 ON 商品表.商品号=销售表.商品号 WHERE 销售表.商品号{"),n("strong",[v._v("IS NULL")]),v._v("}。")]),v._v(" "),n("h3",{attrs:{id:"新一块-标题没想好"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#新一块-标题没想好"}},[v._v("#")]),v._v(" 新一块（标题没想好~）")]),v._v(" "),n("p",[v._v("适合建立"),n("strong",[v._v("索引")]),v._v("的：")]),v._v(" "),n("ol",[n("li",[v._v("查询语句的 WHERE 子句中引用率比较高的列")]),v._v(" "),n("li",[v._v("经常参与连接操作的列。")]),v._v(" "),n("li",[v._v("经常在 order by 子句出现的列")])]),v._v(" "),n("p",[n("strong",[v._v("JOIN....ON 语法格式")]),v._v("：需要连接的表 1 JOIN 需要连接的表 2 ON 连接的条件。")]),v._v(" "),n("p",[v._v("SELECT 查询内容 FROM 表名 表别名 1，表别名 2")]),v._v(" "),n("p",[v._v("SELECT 查询内容\nFROM 表名\nWHERE 条件表达式\nGROUP BY 带分组的列名\nHAVING 列名\nORDER BY 待排序的列名")]),v._v(" "),n("p",[v._v("能够实现分情况显示不同类型数据的函数是{"),n("strong",[v._v("CASE")]),v._v("}")]),v._v(" "),n("p",[v._v("在 SEL 中，用{"),n("strong",[v._v("DISTINCT")]),v._v("}关键词"),n("strong",[v._v("消除重复")]),v._v("出现的元组。")]),v._v(" "),n("p",[v._v("现要统计 T1 表中 C1 列"),n("strong",[v._v("取值不同")]),v._v("的值得个数。请补全下列语句：\nSELECT {"),n("strong",[v._v("COUNT（DISTINCT C1）")]),v._v("} FROM T1")]),v._v(" "),n("p",[v._v("在 T-SQL 中，将查询结果保存到新表（NewTable）中的语句是 SELECT 列 1，列 2{"),n("strong",[v._v("into")]),v._v("} NewTable FROM 表 1。\n"),n("strong",[v._v("SELECT INTO")]),v._v(" 表的复制。")]),v._v(" "),n("p",[v._v("SELECT 查询列表序列 INTO 新表名 "),n("strong",[v._v("FROM 数据源")])]),v._v(" "),n("p",[v._v("设有表 Student（Sno，Sname）、SC（Sno，Cno，Grade），现要查询没选 C01 课程的学生姓名，请补全下列语句：\nSELECT Sname FROM Student WHERE NOT {"),n("strong",[v._v("EXISTS")]),v._v("}（SELECT * FROM SC WHERE Cno=‘C01’ AND Student.Sno=SC.Sno）\n"),n("strong",[v._v("NOT EXISTS 表示查询中没选 C01 课程")])]),v._v(" "),n("p",[v._v("设有表 选课（学号，课程号，成绩），现要查询没选 C01 课程的学生学号。请补全下列语句：\nSELECT 学号 FROM 选课 WHERE 学号{"),n("strong",[v._v("NOT IN")]),v._v("}\n（SELECT 学号 FROM 选课 WHERE 课程号=‘C01’）")]),v._v(" "),n("p",[n("strong",[v._v("WHERE NOT EXISTS")])]),v._v(" "),n("p",[n("strong",[v._v("WHERE 学号 NOT IN")])]),v._v(" "),n("p",[v._v("设有表 Student（Sno，Sname，Sdept），现要查询与“张三”在同一个系的学生姓名。请补全下列语句：\nSELECT{"),n("strong",[v._v("S2")]),v._v("}.Sname FROM Student S1 JOIN Student S2 ON S1.Sdept=S2.Sdept\nWHERE S1.Sname=‘张三’")]),v._v(" "),n("p",[v._v("WHERE 表达式 [NOT] IN（子查询）。")]),v._v(" "),n("p",[v._v("现有系表（系号、系名、联系电话）和教师表（教师号、教师名、职称、工资、系号）。目前某些系还没有招聘到教授，如果要用一个查询语句列出没有招聘到教授的系的系号和系名。用{"),n("strong",[v._v("外")]),v._v("}连接操作可以实现这个查询")]),v._v(" "),n("p",[v._v("设有课程表（课程号，课程名，学分，先修课程号），已知某应用程序小列出“数据库原理”课程的一门先修课程，查询结果要求输出（课程名，学分，先修课名称，先修课学分），可以用{"),n("strong",[v._v("自")]),v._v("}连接操作在一个查询中实现此功能。")]),v._v(" "),n("p",[v._v("自连接就是将一张表"),n("strong",[v._v("当做多张表")]),v._v("来做连接。")]),v._v(" "),n("p",[v._v("SQL Server 2008 提供了 4 个排名函数，其中{"),n("strong",[v._v("RANK")]),v._v("}函数返回结果集中每行数据在每个分区内的排名，并且每个分区内的排名从 1 开始，但排名中间数值可能有间断。")]),v._v(" "),n("p",[v._v("SQL Server 2008 提供了 4 个排名函数，其中{"),n("strong",[v._v("DENSE_RANK")]),v._v("}函数返回结果集中每行数据在每个分区内的排名，并且每个分区内的排名从 1 开始，排名可重复且不间断。")]),v._v(" "),n("p",[v._v("可以匹配 0 到多个字符的通配符是{"),n("strong",[v._v("%")]),v._v("}\n下划线_：可以匹配任意一个字符；\n百分号%：可以匹配 0 到多个字符；\n方括号[]：用于转义。\n尖号^：用于排除一些字符进行匹配。")]),v._v(" "),n("h2",{attrs:{id:"第七章-数据库及数据库对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#第七章-数据库及数据库对象"}},[v._v("#")]),v._v(" 第七章 数据库及数据库对象")]),v._v(" "),n("p",[v._v("在 SQL Server 2008 中，用户数据库的数据文件的主要拓展名为{"),n("strong",[v._v("MDF")]),v._v("}。\n在 SQL Server 2008 中，主要数据文件必须建立在{"),n("strong",[v._v("主")]),v._v("}文件组中。")]),v._v(" "),n("h3",{attrs:{id:"数据库"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据库"}},[v._v("#")]),v._v(" 数据库")]),v._v(" "),n("p",[v._v("每个数据库有且仅有"),n("strong",[v._v("一个主要")]),v._v("数据文件（最小不能小于 3MB），可以有多个次要数据文件。每个数据库必须"),n("strong",[v._v("至少有一个")]),v._v("日志文件，也"),n("strong",[v._v("可以有多个")]),v._v("日志文件。"),n("strong",[v._v("日志文件不包括在文件组内")]),v._v("。一个文件不可以是多个文件组的成员。")]),v._v(" "),n("p",[v._v("主要数据文件和次要数据文件可以放在相同磁盘。\n日志文件和数据文件可以存放在相同的磁盘上。")]),v._v(" "),n("p",[v._v("数据库只有"),n("strong",[v._v("一个主文件组")]),v._v("。")]),v._v(" "),n("p",[v._v("一个数据库的"),n("strong",[v._v("日志")]),v._v("文件的大小和"),n("strong",[v._v("数据")]),v._v("文件的大小之间没有联系")]),v._v(" "),n("p",[v._v("SQL Server "),n("strong",[v._v("实例的作业")]),v._v("信息存储在 "),n("strong",[v._v("msdb")]),v._v(" 数据库中。")]),v._v(" "),n("p",[n("strong",[v._v("用户数据表")]),v._v("的主要数据文件的大小"),n("strong",[v._v("不能小于 model")]),v._v(" 数据库的大小。")]),v._v(" "),n("p",[v._v("用户创建的数据库都自动包含 model 数据库中的内容。")]),v._v(" "),n("p",[v._v("对 "),n("strong",[v._v("model")]),v._v(" 数据库的修改将应用于以后创建的所有用户数据库。")]),v._v(" "),n("p",[v._v("每次"),n("strong",[v._v("启动")]),v._v(" SQL Server 时都会重新创建 "),n("strong",[v._v("tempdb")]),v._v(" 数据库，因此若其损坏，没有必要恢复。")]),v._v(" "),n("p",[n("strong",[v._v("Tempdb")]),v._v(" 是临时数据库，用于保存临时对象或中间结果集，并为数据的排序等操作提供一个临时工作空间。")]),v._v(" "),n("p",[n("strong",[v._v("Resource")]),v._v(" 数据库是个"),n("strong",[v._v("只读")]),v._v("数据库，包含了 SQL Server 中的所有系统对象。")]),v._v(" "),n("p",[n("strong",[v._v("Master")]),v._v(" 数据库记录了所有其他数据库的数据库文件的物理"),n("strong",[v._v("存储位置")]),v._v("。")]),v._v(" "),n("p",[v._v("用户在使用"),n("strong",[v._v("分区表")]),v._v("时不需要考虑操作的是那个表分区，分区对用户是透明的。\n创建分区表就是对表中数据进行水平划分。")]),v._v(" "),n("p",[v._v("创建分区方案时指定的文件"),n("strong",[v._v("组数不少于")]),v._v("分区函数生成的"),n("strong",[v._v("分区数")]),v._v("，否则就会返回错误信息。\n创建分区表的步骤是创建"),n("strong",[v._v("分区函数")]),v._v("、创建"),n("strong",[v._v("分区方案")]),v._v("、使用"),n("strong",[v._v("分区方案创建表")]),v._v("。\n创建分区"),n("strong",[v._v("函数")]),v._v("的目的是告诉数据库管理系统以"),n("strong",[v._v("什么方式对表进行分区")]),v._v("。\n创建分区"),n("strong",[v._v("方案")]),v._v("的作用是将"),n("em",[v._v("分区函数")]),v._v("生成的分区映射到"),n("strong",[v._v("文件组")]),v._v("中。")]),v._v(" "),n("p",[n("strong",[v._v("不同的分区")]),v._v("可以"),n("strong",[v._v("映射到相同的数据库")]),v._v("文件组中。")]),v._v(" "),n("p",[v._v("分区表是从物理上将一个大表划分为几个小表。")]),v._v(" "),n("p",[v._v("CREATE PARTITION FUNCTION PF1（int） AS RANGE "),n("strong",[v._v("LEFT")]),v._v(" FOR VALUES（1,100,200）\n所创建的分区数等于 n+1。\n"),n("strong",[v._v("LEFT")]),v._v("：即 1,100,200 属于左侧。（0,1]，(1,100]，(100,200]，(200,无穷）。\n"),n("strong",[v._v("RIGHT")]),v._v("：即 1,100,200 属于右侧。（0,1），[1,100），[100,200），[200,无穷）。")]),v._v(" "),n("h3",{attrs:{id:"索引-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#索引-2"}},[v._v("#")]),v._v(" 索引")]),v._v(" "),n("p",[v._v("建立索引的一般格式\n"),n("strong",[v._v("CREATE INDEX")]),v._v(" 一般格式为：\n"),n("strong",[v._v("CREATE")]),v._v(" [UNIQUE] "),n("strong",[v._v("INDEX")]),v._v(" <索引名> ON <表名>（<列名>[<次序>],<列名>[<次序>],）INCLUDE （属性名） WHERE 约束条件")]),v._v(" "),n("p",[v._v("设有 T 表，现要在 T 表的 c1 列和 c2 列上建立一个复合唯一聚集索引，其中 "),n("em",[v._v("c1 列值重复率为 20%，c2 列为 10%")]),v._v("。请补全下列语句建立一个性能最优的索引：\n"),n("strong",[v._v("CREATE")]),v._v(" UNIQUE CLUSTERED "),n("strong",[v._v("INDEX")]),v._v(" Idx1 ON T（{ c2，c1}）")]),v._v(" "),n("p",[n("strong",[v._v("UNIQUE")]),v._v(" 是建立唯一索引")]),v._v(" "),n("p",[v._v("对视图创建唯一{"),n("strong",[v._v("聚集")]),v._v("}索引后，视图的结果集将存储在数据库中。\n"),n("strong",[v._v("UNIQUE")]),v._v(" 是对创建的表的属性约束条件，与放在什么位置无关。")]),v._v(" "),n("p",[v._v("使用约束可以保证数据库中数据的正确性，其中{"),n("strong",[v._v("UNIQUE")]),v._v("}约束允许出现空值但不允许出现重复值。\nPRIMARY KEY（主键）不允许出现空值。")]),v._v(" "),n("p",[n("strong",[v._v("聚类算法")]),v._v("将一个数据集中的数据进行分组，使得每一组内的数据"),n("strong",[v._v("尽可能相似")]),v._v("而不同组间的数据尽可能的不同。")]),v._v(" "),n("p",[n("strong",[v._v("CLUSTERED")]),v._v(" 是建立聚集索引。、")]),v._v(" "),n("p",[v._v("建有"),n("strong",[v._v("唯一聚集索引")]),v._v("的视图称为"),n("strong",[v._v("索引视图")]),v._v("。")]),v._v(" "),n("p",[v._v("一个表上只能有一个聚集索引。")]),v._v(" "),n("p",[v._v("在表上建立聚集索引会引起表中数据的物理顺序。")]),v._v(" "),n("p",[v._v("NON"),n("strong",[v._v("CLUSTERED")]),v._v(" 是非聚集索引。")]),v._v(" "),n("p",[v._v("当用户在一个关系表的某一列上建立一个非聚集索引（该表没有聚集索引）时，数据集管理系统会自动为该索引维护一个索引结构。该索引结构中的记录是由{"),n("strong",[v._v("索引列列值")]),v._v("}和它相对应的指针构成的。")]),v._v(" "),n("p",[v._v("在 SQL Server 2008 中，在 T 表的 c1 列上定义唯一非聚集索引（索引名为 idx1）的 SQL 语句是 CREATE {"),n("strong",[v._v("UNIQUE NONCLUSTERED")]),v._v("} INDEX idx1 ON "),n("strong",[v._v("T（c1）")])]),v._v(" "),n("p",[v._v("设在 SQL Server 中，要在 Student 表的 sname 列上建立一个非聚集索引。请补全下列语句\nCREATE NONCLUSTERED INDEX idx1 ON {"),n("strong",[v._v("Student（sname）")]),v._v("}。")]),v._v(" "),n("p",[v._v("设在 SQL Server 2008 中，要在 T1 表的 C1 列上建立一个按降序排序的非聚集索引。请补全下列语句：\nCREATE INDEX idx_t1 ON T1（{"),n("strong",[v._v("C1 DESC")]),v._v("}）")]),v._v(" "),n("p",[v._v("创建"),n("strong",[v._v("索引视图")]),v._v("的步骤：")]),v._v(" "),n("ol",[n("li",[v._v("使用 SCHEMAB INDING 字句来创建一个视图。这个视图必须符合许多要求，"),n("strong",[v._v("它只能引用同一数据库中的基表，而不能是其他标准视图")]),v._v("。所有引用的函数必须是确定性的，行集函数、派生表和子查询都不能在索引视图中使用。")]),v._v(" "),n("li",[v._v("在视图上创建一个唯一索引。这个索引的叶子级由视图的完整结果集组成。")]),v._v(" "),n("li",[v._v("在聚集索引的基础上根据需求创建非聚集索引。非聚集索引可以按平常的方式创建。")]),v._v(" "),n("li",[v._v("创建并使用索引视图。")])]),v._v(" "),n("p",[n("strong",[v._v("索引视图")]),v._v("可以"),n("strong",[v._v("提高")]),v._v("下列查询类型的性能：")]),v._v(" "),n("ol",[n("li",[v._v("处理大量行的"),n("strong",[v._v("连接")]),v._v("和聚合；")]),v._v(" "),n("li",[v._v("许多查询经常执行连接和"),n("strong",[v._v("聚合")]),v._v("操作；")]),v._v(" "),n("li",[v._v("决策支持工作"),n("strong",[v._v("负荷")])])]),v._v(" "),n("p",[v._v("索引视图通常"),n("strong",[v._v("不会提高")]),v._v("下列查询类型的性能：")]),v._v(" "),n("ol",[n("li",[v._v("具有"),n("strong",[v._v("大量写操作的 OLTP 系统")]),v._v("；")]),v._v(" "),n("li",[v._v("具有"),n("strong",[v._v("大量更新的数据库")]),v._v("；")]),v._v(" "),n("li",[v._v("不涉及聚合或联接的查询。")]),v._v(" "),n("li",[n("strong",[v._v("GROUP BU 键具有高基数度的数据聚合")]),v._v("。高基数度表示列包含许多不同的值。当 GROUP BY 后跟的列值包含许多不同的值，导致视图和表的行数相等，那么该列使用索引视图并不能提高查询效率。")])]),v._v(" "),n("p",[n("strong",[v._v("视图")]),v._v("对应数据库的"),n("strong",[v._v("外模式")]),v._v("，因此可以提供一定程序的"),n("strong",[v._v("逻辑独立")]),v._v("性。\n视图是"),n("em",[v._v("虚表")]),v._v("，其"),n("strong",[v._v("数据并不实际保存在数据库")]),v._v("中。\n通过视图进行数据查询时，最终都会转换成对**"),n("em",[v._v("基本表的查询")]),n("strong",[v._v("。\n可以在视图")]),v._v("再定义视图**。")]),v._v(" "),n("p",[v._v("在 SQL Server 2008 中，现要将 T1 表的 C1 列（int 类型）定义为"),n("em",[v._v("标识列")]),v._v("，初值和增量值均为 1。请补全下列语句：\nCREATE TABLE T1（C1 int "),n("strong",[v._v("IDENTITY")]),v._v("（小写 identity）（1,1），......）\n此处用 IDENTYTY 做约束性定义，使 C1 可以成为标识列。")]),v._v(" "),n("p",[n("strong",[v._v("架构")]),v._v("（Schema，也称为模式）是数据库下的一个逻辑命名空间，可以存放表、视图等数据库对象。在同一个数据库中，架构名必须唯一。")]),v._v(" "),n("p",[v._v("架构名可以是显示的，也可以使由 DBMS 提供默认名。")]),v._v(" "),n("p",[v._v("在"),n("strong",[v._v("删除架构")]),v._v("时\n如果使用 "),n("strong",[v._v("CASCADE")]),v._v(" 选项，则会将改架构中的所有架构对象一起全部删除。\n如果使用 "),n("strong",[v._v("RESTRICT")]),v._v(" 选项，如果被删除的架构中包含架构对象，则拒绝删除此架构。\n创建架构的用户必须具有数据库管理员的权限，或者是获得了 CREATE SCHEMA 的权限。")]),v._v(" "),n("p",[v._v("修改数据库用 ALTER 关键字。")]),v._v(" "),n("p",[v._v("ALTER DATABASE 数据库名 MODIFY FILE （NAME=数据文件名，SIZE=文件容量），其中的“文件容量”必须大于原有的容量。")]),v._v(" "),n("p",[v._v("删除数据库用 DROP 关键字。")]),v._v(" "),n("p",[v._v("在 SQL Server 2008 中，若要删除 DB1 数据库中的 U1 用户，请补全下列语句：\nDROP {User} U1\n语法格式：DROP User 用户名。")]),v._v(" "),n("p",[v._v("设在 SQL Server 2008 中，有如下定义的存储过程：\nCREATE PROC P1 @dept varchar（30）=‘计算机系’，@x int\nAS ... ...\n现要调用改存储过程，并且第一个参数用存储过程的默认值。请补全下列语句：\nEXEC P1 {DEFAULT}，20")]),v._v(" "),n("p",[v._v("第八章 数据库后台编程")]),v._v(" "),n("p",[n("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/619086901/619086901.github.io/databaseimg/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png",alt:""}})]),v._v(" "),n("p",[v._v("工资范围为 2000~10000，则选择 smallint")]),v._v(" "),n("p",[v._v("使用 CHECK 进行约束条件限制时，若其只涉及对某一列的约束则可以放在该列后面，如果是约束条件中涉及两列或两列以上，则为对整个数据表的约束，放在表的最后面。")]),v._v(" "),n("p",[v._v("因为经常按照商品类别进行销售数量的汇总分析，因此可以将按商品号分组的销售数量汇总结果保存起来。 为了降低操作时间，可以将频繁使用的统计操作的中间结果保存汇总表中。")]),v._v(" "),n("p",[v._v("多表连接的类型主要有 left join、right join 和 inner join。\nLeft join，返回包括左表中的所有记录和右表连接字段相等的记录。\nRight join，返回包括右表中的所有记录和左表中连接字段相等的记录。\nINNER join，只返回两个表中连接字段相等的行。\n内联表值")]),v._v(" "),n("p",[v._v("内联表值函数的返回值是一个表，该表的内容是一个查询语句的结果；\n内联表值函数的使用与视图非常相似，需要放在查询语句的 FROM 子句中。\n内联表值函数的作用类似于带参数的视图。\n内联表值函数通过 SELECT 语句填充函数返回的表值。")]),v._v(" "),n("p",[v._v("应用题\n在 SQL Server2008 中，每个数据也可存储 8060 字节的数据。设表 T 有 10000 行数据，每行占用 4031 字节，则存储该表数据大约需要{80}MB 存储空间，其空间利用率大约是{50}%\n解析：页的大小为 8KB，也就是说每 MB 有 128 页，每页的开头是 96 字节的标头，用于存储有关页的系统消息，此信息包括页码、页类型、页的可用空间以及拥有该页的对象的分配单元 ID。行不能跨页，但是行的部分可以移出行所在的页，因为行实际可能非常大。\n题目中 2 行数据加起来的存储空间大于数据页，所以每页只能存储一行，因为 1M 有 128 页，也就可以存储 128 行，10000/128 得 80M 空间。\n至于空间利用率（实际存储数据量/所占的存储空间）考虑到每行 4031 字节为 8060 的一半，所以近似得到 50%。")]),v._v(" "),n("p",[v._v("设有学生表（学号，姓名，所在系名）和选课表（学号，课程号，成绩）。现要建立统计每个系选课人数的视图。请补全下列语句：\nCREATE VIEW V1（系名，人数）AS\nSELECT 所在系名，{COUNT（DISTINCT 选课表.学号）}\n使用 DISTINCT 取消重复值。\nALL 的话保留重复值。\nFROM 选课表 JOIN 学生表 ON 选课表.学号=学生表.学号\n{GROUP BU 所在系名}")]),v._v(" "),n("p",[v._v("在 SQL Server 2008 中，计算两个日期之差的函数是{datediff（）}。")]),v._v(" "),n("p",[v._v("存储过程 output\n设在 SQL Server 2008 某数据库中有按如下格式定义的存储过程首部：\nCREATE PROC P1\n@x int，@y int，@z int output AS....\n请补全下列调用该存储过程的语句。\nDECLARE @S int\nEXEC P1 20,30，@S {output}")]),v._v(" "),n("p",[v._v("DECLARE @ S int output 错误，在调用存储过程时，只需要声明参数的类型，不能指明参数为输出参数。")]),v._v(" "),n("p",[v._v("存储过程可以进行模块化程序设计。")]),v._v(" "),n("p",[v._v("返回结果可以是一个集合。")]),v._v(" "),n("p",[v._v("过程 PROC\n下面程序段的功能是：在数据库中判断是否存在名为 my_proc 存储过程，若存在，则删除之，然后创建同名的存储过程，改存储过程的功能是向 author_id、author_name、address 和 telephone 字段插入数据。阅读并回答以下问题：\nUSE bookdb GO\nIF EXISTS（SELECT {Name} FROM Sysobjects\nWHERE name=‘my_proc’ and type=‘P’）\nDROPPROC my_proc GO")]),v._v(" "),n("p",[v._v("CREATE PROC my_proc\n@a int, @b char (8), @c char (50) {as}\nINSERT INTO author(author_id,author_name,address)VALUES(@a,@b,@c) GO")]),v._v(" "),n("p",[v._v("即从系统表中查询有没有和 my_proc 同名的过程，用“SELECT name FROM Sysobjects”。\n其中 Sysobjects 为系统表，")]),v._v(" "),n("p",[v._v("创建过程的命令格式：\nCREATE PROC my_proc\n@变量 1，@变量 2 AS")]),v._v(" "),n("p",[v._v("创建存储过程的命令格式\ncreate procedure test*sp\n@baipar1 varchar (8),\n@par2 int\nas\nDECLARE\n@某商品销售量 int ，@。。。int /"),n("em",[v._v("中间定义变量")]),v._v("/\nbegin\nselect * from table1 where col1 = @par1 and col2 = @par2（SQL 语句）查询赋值\nend\nSET @毛利=（@某商品销售单价-@某商品进价）_@某商品销售量（SET 赋值）")]),v._v(" "),n("p",[v._v("SQL Server 中有五种约束类型，分别是主键约束、{外键约束}（FOREIGN KEY）、唯一性约束（UNIQUE）、缺省约束（DEFAULT）和检查约束（CHECK）。")]),v._v(" "),n("p",[v._v("在 SQL Server 2008 中，设有顾客表（顾客号，顾客名，所在地区，年龄），应用系统中需统计指定地区的顾客人数和平均年龄。请补全下列存储过程代码以完成该功能。\nCREATE PROC P_Count\n@area varchar（20）\nAS\nSELECT COUNT（*） AS 人数，{AVG（年龄）} AS 平均年龄 FROM 顾客表 WHERE 所在地区=@area")]),v._v(" "),n("p",[v._v("设有商品表（商品号，商品名，类别），现要建立查询指定类别的商品数量的存储过程。请补全下列语句\nCREATE PROC P_COUNT（@x AS varchar（20））\nAS\nSELECT count（*） from 商品表\nWHERE 类别={@x}")]),v._v(" "),n("p",[v._v("该类别值来源用户定义的变量的值。")]),v._v(" "),n("p",[v._v("设某数据库中作者表（作者号、城市）和出版商表（出版商好，城市）。请补全如下查询语句，使该查询语句能查询出在作者表里而不在出版商表中的城市。\nSELECT 城市 FROM 作者表\n{WHERE 作者.城市 NOT IN}\n（SELECT 城市 FROM 出版商表）")]),v._v(" "),n("p",[v._v("标量函数 FUNCTION\n删除用户自定义的函数使用{DROP FUNCTION}语句来实现。")]),v._v(" "),n("p",[v._v("在 T-SQL 中，修改用户自定义函数 fun1 的 T-SQL 语句是{ALTER FUNCTION} fun1...")]),v._v(" "),n("p",[v._v("定义 CREATE FUNCTION—定义一个新函数。")]),v._v(" "),n("p",[v._v("在 SQL Server 2008 中，用户自定义函数主要包括标量函数和{表值}函数两类")]),v._v(" "),n("p",[v._v("标量函数公式：\nCREATE FUNCTION ...\nReturns int [AS]\nBEGIN\nReturn（）\nEND")]),v._v(" "),n("p",[v._v("一个有 s 一个没有 s。")]),v._v(" "),n("p",[v._v("开窗函数 OVER\n设有课程表（课程号，课程名，开课学期）和选课表（学号，课程号，成绩），现要利用开窗函数查询每个学生的姓名、所在系及选课门数（不包括没选课的学生）。请补全下列语句：\nSELECT DISTINCT 姓名，所在系，COUNT（*）{OVER（PARTITION BU T1.学号） AS 选课人数 FROM 学生表 T1 JOIN 选课表 T2 ON T1.学号=T2.学号")]),v._v(" "),n("p",[v._v("开窗函数公式：函数名（列）OVER（选项）。")]),v._v(" "),n("p",[v._v("游标 FETCH\n在 T-SQL 中，提取 cur1 游标中相对于当前行向下第 5 行数据的语句是：\nFETCH {RELATIVE} FROM cur1 ...")]),v._v(" "),n("p",[v._v("在 T-SQL 中，提取游标 cur1 第 5 行数据的语句是：\n{FETCH} ABSOLUTE 5 FROM cur1...")]),v._v(" "),n("p",[v._v("请补全下列从游标提取下一行数据的语句\n{FETCH NEXT} FROM cur1 INTO...")]),v._v(" "),n("p",[v._v("FETCH 【NEXT | PRIOR | FIRST | LAST | ABSOLUTE | RELATIVE 】")]),v._v(" "),n("p",[v._v("NEXT：返回紧跟当前行之后的数据行，并且当前行递增为结果行。默认就是（后一行）")]),v._v(" "),n("p",[v._v("PRIOR：搜索返回紧跟在当前行前面的数据行，并且当前行递减为结果行。（前一行）")]),v._v(" "),n("p",[v._v("FIRST：返回游标中的第一行并将其作为当前行。")]),v._v(" "),n("p",[v._v("LAST：返回游标中的最后一行并将其作为当前行。")]),v._v(" "),n("p",[v._v("ABSOLUTE：n 为正则，返回游标第一行开始的第 n 行，n 为负则，返回游标最后一行开始之前的第 n 行")]),v._v(" "),n("p",[v._v("RELATIVE：n 为正则，返回当前行之后的第 n 行，并将返回行变成新的当前行。n 为负则，返回当前行之前的第 n 行，并将返回行变成新的当前行。")]),v._v(" "),n("p",[v._v("在 T-SQL 中，提取 cur1 游标中倒数第 5 行数据的语句是：\nFETCH ABSOLUTE {-5} FROM cur1")]),v._v(" "),n("p",[v._v("每一个游标都有一个当前行指针，当游标打开后，当前行指针自动指向结果集的第一行数据。")]),v._v(" "),n("p",[v._v("用户不可以对@@FETCH_STATUS 变量进行赋值。\n用户不可以在游标中声明@@FETCH_STATUS 变量。")]),v._v(" "),n("p",[v._v("系统都会对@@FETCH_STATUS 赋一次值，以表明 FETCH 语句的执行情况。")]),v._v(" "),n("p",[v._v("当@@FETCH_STATUS = 0 时，表示的含义是 FETCH 语句成功；\n@@FETCH_STATUS = -1 时，FETCH 语句失败或行不在结果集中；\n@@FETCH_STATUS = 2 时，提取的行不存在；")]),v._v(" "),n("p",[v._v("游标由游标{结果集}和{游标当前行指针}两部分组成。")]),v._v(" "),n("p",[v._v("如果声明游标时不指定 SCROLL 选项，则在对游标进行 FETCH 操作时只能指定 NEXT。\n对游标进行 FETCH 操作后，可以使用@@FETCH_STATUS 变量判断数据提取状态。")]),v._v(" "),n("p",[v._v("当使用 CLOSE 语句关闭游标后，需使用 DEALLOCATE 命令释放系统为游标分配的资源。")]),v._v(" "),n("p",[v._v("关闭游标之后，可以通过 OPEN 语句再次打开该游标。")]),v._v(" "),n("p",[v._v("在 SQL Server2008 中，用于判断游标数据提取状态的全局变量是{@@FETCH_STATUS}")]),v._v(" "),n("p",[v._v("声明游标语句 cursor\nSQL Server 2008 中声明游标的语句为：DECLARE x cursor {FOR} SELECT")]),v._v(" "),n("p",[v._v("设有如下定义游标的 T-SQL 语句：")]),v._v(" "),n("p",[v._v("DECLARE cur1 CURSOR FOR SELECT * FROM...")]),v._v(" "),n("p",[v._v("触发器 TRIGGER\n在 T-SQL 中，修改触发器 tri1 的语句是{ALTER TRIGGER} tri1....")]),v._v(" "),n("p",[v._v("设要在表 T 上建立一个针对插入操作的前触发器，请补全下列语句：\nCREATE TRIGGER tri_insert ON T {INSTEAD OF} INSERT。")]),v._v(" "),n("p",[v._v("INSTEAD OF 创建前触发器，FOR 或 AFTER 创建后触发器。")]),v._v(" "),n("p",[v._v("不能在视图上定义后触发器（AFTER 型触发器）。")]),v._v(" "),n("p",[v._v("使用触发器实现数据完整性的效率通常低于 CHECK 约束。")]),v._v(" "),n("p",[v._v("前触发型触发器只执行触发器指定的内容而不执行引发触发器的 SQL。（前触发器执行了就不执行后面的 SQL 语句了）\n后触发型触发器表示事件发生之后。")]),v._v(" "),n("p",[v._v("一张表可以建立多个后触发器，针对同一个数据操作只能建立一个前触发器")]),v._v(" "),n("p",[v._v("触发器有 3 种类型，即 INSERT 类型、UPDATE 类型和{DELETE 类型}\n触发器的组成部分：")]),v._v(" "),n("ol",[n("li",[v._v("触发器的声明，指定触发器定时，事件，表名和类型。")]),v._v(" "),n("li",[v._v("触发器的执行，PL/SQL 块或对过程的调用。")]),v._v(" "),n("li",[v._v("触发器的限制条件，通过 where 子句实现。")])]),v._v(" "),n("p",[v._v("在 SQL Server 2008 中，对于更新操作的触发器，系统将产生 2 张逻辑工作表，其中存放更新前数据的逻辑工作表是{DELETED 表}。")]),v._v(" "),n("p",[v._v("DELETED 表用于存储 DELETE 和 UPDATE 语句所影响的行的副本。\nINSERTED 表用于存储 INSERT 和 UPDATE 语句所影响的行的副本。\n触发器在执行时并非会同时生成 INSERTED 表和 DELETED 表。\n对于更新操作的触发器，系统将产生两张逻辑工作表，即 DELETED 表和 INSERTED 表。")]),v._v(" "),n("p",[v._v("DELETED 表用于存储更新前数据，\nINSERTED 用于更新后的数据（INSERT 和 UPDATE）。\n在 SQL Server 2008 的触发器中，用于存储 DELETED 语句所影响的行的复本表为{DELETED}")]),v._v(" "),n("p",[v._v("在 T-SQL 语言中，如果要将 T1 表中的全部数据复制到 T2 表中，T2 表已存在，可使用语句：\n{INSERT INTO} T2 SELECT * FROM T1")]),v._v(" "),n("p",[v._v("第九章 安全管理\nSELECT、INSERT、DENY UPDATE，DENY 优先，有权执行的操作只有 SELECT 和 INSERT")]),v._v(" "),n("p",[v._v("RAID10 比 RAID5 在写数据上更稳定、速度更快。\nRAID1 比 RAID5 在写数据上更稳定、速度更快。")]),v._v(" "),n("p",[v._v("RAID1 提高了读写速度但磁盘利用率低\nRAID5 写入数据的速度比 RAID1 慢，但磁盘利用率比 RAID1 高。")]),v._v(" "),n("p",[v._v("数据库强制存取控制方法的规则是：\n仅当主体的许可证级别大于或等于（不低于）客体的密级时，主体才能读取相应的客体。\n仅当主体的许可证级别等于（不高于）客体的密级时，主题才能写相应的客体。")]),v._v(" "),n("p",[v._v("自主存取控制主要通过 GRANT（授权）、REVOKE（回收）、DENU 拒绝语句来实现。")]),v._v(" "),n("p",[v._v("在强制存取控制中，DBMS 将实体划分为主体和客体两大类。")]),v._v(" "),n("p",[v._v("强制存取控制本质上是分层次的，它比自主存取控制更严格。")]),v._v(" "),n("p",[v._v("四类安全级别：\nA 类提供验证保护。\nB 类提供强制保护。\nC 类提供资助保护。\nD 类提供最小保护。")]),v._v(" "),n("p",[v._v("数据库用户可分为系统管理员、对象拥有者和普通用户三类。")]),v._v(" "),n("p",[v._v("在“Windows 身份验证模式”下，所有 Windows 用户登录到 SQL Server 服务器都无需再提供用户名和密码，但 SQL Server 会从用户登录到 Windows 时提供的用户名和密码查找当前用户的信息，判断其是否是 SQL Server 的合法用户。")]),v._v(" "),n("p",[v._v("在“Windows 身份验证模式”下，不允许 sa 登录到 SQL Server 服务器。")]),v._v(" "),n("p",[v._v("只有在“混合身份验证模式”下，sa 才能登录到 SQL Server。")]),v._v(" "),n("p",[v._v("在“混合身份验证模式”下，允许 Windows 用户和非 Windows 用户登录到 SQL Server。")]),v._v(" "),n("p",[v._v("不管是哪种身份验证模式，Windows 中的 Administrator 无需授权就可登录到 SQL Server 服务器。")]),v._v(" "),n("p",[v._v("SQL Server 和 Windows 身份验证模式也称为混合身份模式。")]),v._v(" "),n("p",[v._v("安装好 SQL Server 之后，可以根据需要随时更改身份验证模式。")]),v._v(" "),n("p",[v._v("在 SQL Server 2008 中，有两种身份验证模式，一种是混合身份验证模式，另一种是{Windows}身份验证模式。\n在 SQL Server 2008 中，设 log1 是 SQL Server 身份验证模式的数据库服务器登录账户。现要授予 log1 具有创建数据库的权限，请补全下列语句：\nEXEC sp_addsrvrolemember ‘log1’，‘{dbcreator}’")]),v._v(" "),n("p",[v._v("在 SQL Server 2008 中，设 log1 是 SQL Server 身份验证模式的数据库服务器登录账户。现要授予 U1 在该数据库服务器上具有系统管理员权限。请补全下列语句：\nEXEC sp_addsrvrolemember ‘U1’，‘{sysadmin}’")]),v._v(" "),n("p",[v._v("guest（客人）用户\nguest 用户没有对应的登录账户名。")]),v._v(" "),n("p",[v._v("通过授权语句可以启用数据库中的 guest 用户。")]),v._v(" "),n("p",[v._v("任何 SQL Server 登录账户都可以访问启用了 guest 用户的数据库。")]),v._v(" "),n("p",[v._v("除了 guest 外，每个数据库用户都必须有对应的登录账户。")]),v._v(" "),n("p",[v._v("一个登录账户可以映射为多个数据库中的用户。")]),v._v(" "),n("p",[v._v("当登录账户称为数据库中的合法用户之后，该账户除了具有一些系统视图的查询权限之外，对数据库中的用户数据和对象不具有任何操作权限。")]),v._v(" "),n("p",[v._v("sa 是系统定义的一个数据库登录账户。")]),v._v(" "),n("p",[v._v("在 SQL Server 2008 中，登录账户的来源共有{两}种。")]),v._v(" "),n("p",[v._v("在 SQL Server 2008 中，若要删除 U1 登录账户，请补全下列语句：\nDROP {LOGIN} U1\n解析：删除 SQL Server 登录账户语法为 DROP LOGIN login_name")]),v._v(" "),n("p",[v._v("设在 SQL Server 中，要创建 SQL Server 身份验证的登录账户，登录名为：User1，密码为：a123。请补全下列语句\nCREATE {LOGIN} User1 WITH PASSWORD=‘a123’")]),v._v(" "),n("p",[v._v("数据库备份 BACKUP\n在 SQL Server 2008 中，若要将 DB1 数据库完整备份到 BK 设备上，请补全下列语句：{BACKUP} DATABASE DB1 TO BK")]),v._v(" "),n("p",[v._v("拒绝 DENY\nDENY 对象权限名 ON {表名|视图} TO {数据库用户名|用户角色名}")]),v._v(" "),n("p",[v._v("设在 SQL Server 2008 某数据库中，要设置不允许用户 U1 获得对表 T 数据的删除权限，请补全实现该授权操作的 SQL 语句：\n{DENY DELETE} ON T TO U1")]),v._v(" "),n("p",[v._v("授权命令 GRANT\nGrant <权限> on 表名[(列名)] to 用户\n如果要使某用户可以将授予他的权限再转授给其他用户，那么在授权语句中需要加上{WITH GRANT OPTION}选项。")]),v._v(" "),n("p",[v._v("GRANT CREATE TABLE TO U1 授予用户 U1 在 DB1 数据库中具有建表的权限。")]),v._v(" "),n("p",[v._v("GRANT UPDATE ON T1 TO U1\n具有 UPDATE T1 SET c1=100\n不具有 SELECT 权限\n不具有 UPDATE T1 SET c1=c1+100\n不具有 UPDATE T1 SET c1=c3+c1\n不具有 UPDATE T1 SET c1=100 WHERE c2=‘A’")]),v._v(" "),n("p",[v._v("回收权限 REVOKE\nREVOKE <权限> ON <数据对象> FROM <数据库用户名>")]),v._v(" "),n("p",[v._v("在使用 REVOKE 命令回收用户权限时，如果要将该用户转授给其他用户的权限也一并回收，则命令中需要加上{CASCADE}选项")]),v._v(" "),n("p",[v._v("主要角色和权限\nbulkadmin：具有执行 BULK INSERT 语句。\ndbcreator：具有创建、修改、删除和还原数据库。\ndiskadmin：具有管理磁盘文件的权限。\nprocessadmin：管理在 SQL Server 实例中运行的进程。\nsecurityadmin：管理服务器登录账户。\nserveradmin：具有设置服务器级别的配置选项和关闭服务器的权限。\nselupadmin：添加和删除连接服务器。\nsysadmin（系统管理员）：具有在服务器及数据库上执行任何操作的权限。")]),v._v(" "),n("p",[v._v("内置的角色：\ndb_owner：具有在数据库中执行任何操作的权限，包括配置、维护数据库及删除数据库。\ndb_accessadmin：可以增加或删除数据库用户的权限。\ndb_backupoperator：具有备份数据库、备份日志的权限。\ndb_datareader：具有查询数据库中所有用户数据的权限。是数据库级角色，\ndb_datawriter：具有插入、删除和更新数据库中所有用户的权限。（没有查询的功能）\ndb_ddladmin：具有执行数据定义语言的权限。\ndb_denydatareader：不允许具有查询数据库中所有用户的权限。\ndb_denydatawriter：不具有插入、删除和修改数据库中所有用户数据的权限。\ndb_securityadmin：具有管理数据库角色、角色成员以及数据库中语句与对象的权限。\npublic：默认角色。")]),v._v(" "),n("p",[v._v("Oracle 的安全控制可分为数据库级、表级、行级和列级。")]),v._v(" "),n("p",[v._v("数据库级的安全性通过用户身份认证和授予用户。")]),v._v(" "),n("p",[v._v("Oracle 数据库中的用户按其操作权限大小可分 DBA 用户和普通用户。")]),v._v(" "),n("p",[v._v("第十章 数据库运行维护与优化")]),v._v(" "),n("p",[v._v("数据库系统的更新既包括应用系统及其相关的数据库对象，也包括数据库管理系统及其所在的操作系统的环境。")]),v._v(" "),n("p",[v._v("监控分析\n数据库的监控分析可以分为对数据库架构体系的监控（主要内容：空间基本信息、空间使用率与剩余空间大小、空间是否具有自动扩展的能力、那些表的扩展将引起空间的扩展、段的占用空间与区间数）和对数据库性能的监控（主要包括：数据缓冲区的命中率、库缓冲、用户锁、锁与等待、回滚段、临时段使用情况、索引的使用情况、等待事件和共享池）\n索引使用情况。\n数据库是否可用，用户是否可连接。\n监控的是数据库，不是数据库系统。")]),v._v(" "),n("p",[v._v("数据库管理员（DBA）日常管理工作有：系统监控与分析（监控数据库用户连接数）、系统性能优化调整、系统进化、并发控制（监控并处理事务死锁）、存储空间管理、安全性维护（数据出现问题时恢复数据库数据以核查问题）、完成性维护、备份与恢复等。")]),v._v(" "),n("p",[v._v("数据库运行维护工作：\n为了保证安全，定期修改数据库用户的密码。\n更换数据库服务器以提高应用系统运行速度。\n恢复数据库数据以核查问题。\n数据库补丁安装。\n调整数据库用户权限。\n引入汇总表来提高经常执行的聚集查询的性能。")]),v._v(" "),n("p",[v._v("提高系统的事务并发度：\n尽可能使用行锁。\n设定较低的事务隔离等级。\n将大事务切分成小事务。")]),v._v(" "),n("p",[v._v("数据库管理系统一般通过周期性检查{事务等待}图来实现死锁检测。")]),v._v(" "),n("p",[v._v("一个事务执行过程中，其正在访问的数据被其他事务修改，导致处理结果不正确。这是由于不满足并发事务间的{隔离}性而引起的")]),v._v(" "),n("p",[v._v("优化 SQL 语句执行效率属于数据库应用系统{运行管理与维护}阶段的任务。")]),v._v(" "),n("p",[v._v("数据库维护的主要内容有以下几方面：")]),v._v(" "),n("ol",[n("li",[v._v("数据库的转储和恢复；")]),v._v(" "),n("li",[v._v("数据库安全性、完整性控制（新建数据库用户）；")]),v._v(" "),n("li",[v._v("数据库性能的检测和改善；要求熟悉系统环境、数据库管理系统、应用程序以及应用程序所使用的数据。")]),v._v(" "),n("li",[v._v("数据库的重组和重构；")])]),v._v(" "),n("p",[v._v("数据库重组是指按照系统设计要求对数据库存储空间进行全面调整，如调整磁盘分区方法和存储空间、重新安排数据的存储、整理回收碎块等，以提高数据库性能。")]),v._v(" "),n("p",[v._v("数据库维护过程中，管理员应定期对数据库进行{重组}，即对数据库进行整理回收碎块，重新安排数据的存储，重建索引等操作。")]),v._v(" "),n("p",[v._v("数据库的重组并不修改数据库原有设计的逻辑结构和物理结构")]),v._v(" "),n("p",[v._v("而数据库的重构则不同，他可以部分修改数据库的模式和内模式。")]),v._v(" "),n("p",[v._v("重构工作一般会改变数据库逻辑结构。")]),v._v(" "),n("p",[v._v("数据库的重构是指由于数据库应用环境的不断变化，增加了新的应用或新的尸体，取消了某些应用，有的实体与实体间的联系也发生了变化等，使得原有的数据库设计不能满足新的需求，此时需要调整数据库的模式和内模式。")]),v._v(" "),n("p",[v._v("性能调优的说法：")]),v._v(" "),n("p",[v._v("有时候对应用程序的修改需要应用开发人员配合才能完成。")]),v._v(" "),n("p",[v._v("修改某些频繁使用的 SQL 语句，提高性能，可降低数据库 CPU 使用率。")]),v._v(" "),n("p",[v._v("挡数据库服务器磁盘 IO 出现写瓶颈时，可以考虑使用高速磁盘存储常用数据，低速磁盘存储不常用数据。")]),v._v(" "),n("p",[v._v("索引可以提高某些查询的速度，但也可能降低写入速度，同时也会增加磁盘空间使用。")]),v._v(" "),n("p",[v._v("优化 SQL 语句执行效率属于数据库应用系统{运行管理与维护}阶段的任务。")]),v._v(" "),n("p",[v._v("数据库管理员要随时观察数据库的动态变化，并在数据库出现错误、故障或产生不适应的情况时能够随时采取有效措施保护数据库。这种监控机制称为{手动监控机制}。")]),v._v(" "),n("p",[v._v("为了提高数据库性能，在销售单据表中增加“总价”字段（由表中“单价”×“数量”计算而来），此种数据库优化方法被称为增加{派生}冗余列方法。")]),v._v(" "),n("p",[v._v("派生性冗余列指表中增加的列由表中的一些数据项经过计算而成，它的作用是查询时减少连接操作，避免使用聚合函数。")]),v._v(" "),n("p",[v._v("增加派生性冗余列可以降低查询过程中的计算量。")]),v._v(" "),n("p",[v._v("增加冗余列关系模式将不符合第三范式要求。")]),v._v(" "),n("p",[v._v("增加冗余列一般不能减少数据分组操作带来的资源消耗。")]),v._v(" "),n("p",[v._v("派生性冗余列一般无法减少聚合函数的使用。")]),v._v(" "),n("p",[v._v("需要使用触发器或应用程序改造等方法保证数据一致性。")]),v._v(" "),n("p",[v._v("适当降低关系模式的规范化程度，可以减少查询过程中的 JOIN 操作。")]),v._v(" "),n("p",[v._v("SQL Server Agent 是一个任务规划期和警报管理器。\n主要包括以下几个组件：作业、警报、操作。")]),v._v(" "),n("p",[v._v("在数据库系统中，{外模式/模式}映像关系用于提供数据与应用程序间的逻辑独立性。")]),v._v(" "),n("p",[v._v("优化查询：")]),v._v(" "),n("p",[v._v("避免或简化排序的目的是实现查询优化。")]),v._v(" "),n("p",[v._v("将频繁操作的多个可以分割的处理过程放在多个存储过程中，这样可以大大提高系统的响应速度。")]),v._v(" "),n("p",[v._v("使用游标会占用较多的系统资源，尤其对于大规模并发量的情况下，很容易使得系统资源耗尽而崩溃，而使用临时表能够加速查询。")]),v._v(" "),n("p",[v._v("相关子查询的不可以加速查询。")]),v._v(" "),n("p",[v._v("很少用到商品描述属性，可以将其单独存储。")]),v._v(" "),n("p",[v._v("因为经常执行商品表和销售表之间的连接操作，可以将他们组织成聚集文件。")]),v._v(" "),n("p",[v._v("将经常一起使用的具有公共列值的多个表中的数据行存储在一起的数据库存储方法被称为{聚集}。")]),v._v(" "),n("p",[v._v("因为经常按照商品号对销售表执行分组操作，可以将销售表组织成散列文件。")]),v._v(" "),n("p",[v._v("分割表\n水平分割表：一种是当多个过程频繁访问数据表的不同行时，水平分割表，并消除新表中的冗余数据列；另一种是当主要过程重复访问部分行时，最好将这部分被频繁访问的这些行单独子集表（冗余储存）这在不考虑磁盘空间开销时显得十分重要，但因此增加了重叠列的维护难度，要用触发器立即更新、或用存储过程及应用代码批量更新，这也会增加额外的磁盘 I/O 开销。")]),v._v(" "),n("p",[v._v("在使用分割表进行数据库优化时，进行{水平}分割之后得到的所有表结构都相同，而存储的数据不同。水平分割会给应用增加复杂度，大部分情况时局部使用")]),v._v(" "),n("p",[v._v("水平分割后，查询数据需要使用 UNION 操作。（并）")]),v._v(" "),n("p",[v._v("垂直分割表（不破坏第三范式）：\n减少磁盘 I/O，更新时不必考虑锁，没有冗余数据。")]),v._v(" "),n("p",[v._v("垂直分割后，所有表中均需保留原有表的主码。")]),v._v(" "),n("p",[v._v("缺点：是在插入或删除数据时要考虑数据的完整性，用存储过程维护。另一种是当主要过程反复访问部分列时，最好将这部分被频繁访问的列数据单独存为一个子集表（冗余储存）这在不考虑磁盘空间开销时显得十分重要，但因此增加了重叠列的维护难度，要用触发器立即更新、或用存储过程及应用代码批量更新，这也会增加额外的磁盘 I/O 开销。")]),v._v(" "),n("p",[v._v("垂直分割后，查询数据需要使用 JOIN 操作。（连接）")]),v._v(" "),n("p",[v._v("垂直分割表可以达到最大化利用 Cache 的目的。")]),v._v(" "),n("p",[v._v("操作型数据与分析性数据的区别如以下表格所示。\n对比项 操作型系统 分析型系统\n数据源 应用的操作信息，一般是最原始的数据 历史的、归档的数据、一般来源于数据仓库\n侧重点 数据更新 信息的检索或报表\n应用 管理系统、交易系统、在线应用等 报表系统、多维分析、决策支持系统等\n用户 终端用户、普通雇员 管理人员、市场人员、数据分析师\n任务 业务操作 数据分析\n数据更新 插入、更新、删除数据，要求快速执行，立即返回结果 大量数据装载，花费时间很长\n数据模型 实体关系模型 多维数据模型\n设计方法 规范化设计，大量的表和表之间的关系 星型模式或雪花模式，少量的表\n备份 定期执行全量和增量备份，不允许数据丢失 简单备份，数据可以重新装载\n数据的时间范围 从天到年 几年或几十年\n查询 简单查询，快速返回查询结果 查询复杂，执行聚合或汇总操作\n速度 快，大表上需要建索引 相对较慢，需要更多的索引\n所需空间 小，只存储操作数据 大，需要存储大量历史数据\n操作型数据对性能要求较高、无冗余。\n• 数据时间范围：\n• 操作型数据库只会存 90 天以内的数据；\n• 分析型数据库存放数年内\n•\n• 数据细节层次：\n• 操作型数据库存放的主要是细节数据（详细）；\n• 分析型数据库，既有细节数据，又有汇总数据（综合）")]),v._v(" "),n("p",[v._v("• 数据时间表示：\n• 操作型数据库反映当前状态；\n• 分析型数据库，既有当前状态，又有过去各时刻的快照")]),v._v(" "),n("p",[v._v("• 数据更新：\n• 操作型允许用户进行增、删、改、查；（更新频率高）\n• 分析型只能查。（一般不更新）")]),v._v(" "),n("p",[v._v("• 数据冗余；\n• 操作型减少数据冗余、避免更新异常；（无冗余）\n• 而分析型存在数据冗余。（有冗余）")]),v._v(" "),n("p",[v._v("• 数据读者：\n• 操作型使用者是业务环境内的各个角色；\n• 分析型数据库是被少量用户用来做综合性决策的。")]),v._v(" "),n("p",[v._v("• 操作型数据处理需求事先可知，\n• DSS 型数据处理需求事先不明确。")]),v._v(" "),n("p",[v._v("• 数据定位：\n• 操作型是为了支撑具体业务的，称为“面向应用型数据库”；\n• 分析型是针对各特定业务主题域的分析任务创建，称为“面向主题型数据库”")]),v._v(" "),n("p",[v._v("物化视图\n物化视图是预先计算并保持表连接或聚集等耗时较多的操作结果，这样，在执行查询大大提高了读取速度。")]),v._v(" "),n("p",[v._v("物化视图有很多方面和索引很相似：使用物化视图的目的是为了提高查询性能；")]),v._v(" "),n("p",[v._v("物化视图对应用透明，增加和删除物化视图不会影响应用程序中 SQL 语句的正确性和有效性，物化视图需要占用存储空间，当基表发生变化时，物化视图可以手动刷新也可以定时自动刷新；存储过程是相当于加载到数据库上的模块，因此在此运行时不用重新编译，但其与数据库管理系统绑定，因此如果在更改数据库管理系统时，需要重新绑定存储过程。在数据库性能优化期间有可能改动原有的符合范式。")]),v._v(" "),n("p",[v._v("在数据库性能优化中，建立物化视图和聚集属于{空间换时间}优化方法。")]),v._v(" "),n("p",[v._v("新增汇总表的调优方法是一种以空间换{时间}的调优方法。")]),v._v(" "),n("p",[v._v("{物化或索引}视图不是在使用时才读取基本表，而是预先计算并保存操作结果，这样在查询时大大提高了读取速度。")]),v._v(" "),n("p",[v._v("索引\n索引适合使用的条件：\n在经常需要搜索的列上，可以加快搜索的速度。\n在经常使用连接的列上可以加快连接的速度。\n在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的。（聚集索引）\n在经常使用 WHERE 子句中的列上面创建索引，加快条件的判断速度。\n一个列的值域很大时，应为其建立索引。\n表中数据大量更新后重建相关索引也可以提高查询速度。\n频繁进行排序或分组（group by 或 order by）的列。")]),v._v(" "),n("p",[v._v("索引有可能会占用大量磁盘空间，建立索引时需要考虑其空间需求。\n在某个查询中带排序的属性有多个时可以考虑在这些属性上建立复合索引。")]),v._v(" "),n("p",[v._v("在多属性（组合）索引中，索引属性的顺序是按照其分区度进行排序。")]),v._v(" "),n("p",[v._v("当数据表更新大量数据后一般需要重建对应的 B 树索引。")]),v._v(" "),n("p",[v._v("散列索引根据 HASH 算法构建索引，所以检索速度很快，但不能用于范围查询。（散列索引不能用于范围查询）")]),v._v(" "),n("p",[v._v("不适合使用的条件：\n对于那些在查询中很少使用或者参考的列不应该创建索引。\n对于那些只有很少数据值的列也不应该创建索引。\n经常进行更新的列不适宜创建索引。")]),v._v(" "),n("p",[v._v("带有 Order By 和 Group By 的表可以使用散列文件存储，可以提高查询效率。")]),v._v(" "),n("p",[v._v("数据文件和索引文件不能放在一起")]),v._v(" "),n("p",[v._v("SQL Server 2008 数据库中，{索引}视图是存储一个查询结果的数据库对象。")]),v._v(" "),n("p",[v._v("第十一章 故障管理")]),v._v(" "),n("p",[v._v("当事务 T 对某个数据加上排它锁时，T 可以对该数据进行读和写，其他任何事务都不能再对该数据加任何类型的所，直到 T 释放该锁才行。")]),v._v(" "),n("p",[v._v("当事务 T 对某个数据加上共享锁，则 T 只能对该数据进行读操作，不能修改数据，且其他事务也可以对该数据加共享锁但不能加排它锁。只有等到该数据没有被其他任何事务访问时才能加排它锁。")]),v._v(" "),n("p",[v._v("数据库管理系统中的加锁协议规定了事务的加锁时间、执锁时间和释放锁时间，其中{三级加锁}协议可以完全保证并发事务数据的一致性。")]),v._v(" "),n("p",[v._v("两阶段加锁协议可以保证事务调度的{可串行}性。")]),v._v(" "),n("p",[v._v("锁是一种特殊的二元信号量，用来控制多个并发事务对共享资源的使用。")]),v._v(" "),n("p",[v._v("数据库管理系统可以采用先来先服务的方式防止出现活锁现象。")]),v._v(" "),n("p",[v._v("完整恢复模式完整地记录所有事务，并将事务日志保留至其备份完毕。")]),v._v(" "),n("p",[v._v("对于用户数据库，简单恢复模式只用于测试和开发数据库，或用于主要包含只读数据的数据库（如数据仓库），这种模式并不适合生产系统，因为对生产系统而言，丢失最新的更改是无法接受的。")]),v._v(" "),n("p",[v._v("SQL Server 2008 支持数据库、数据文件两个级别的数据恢复。")]),v._v(" "),n("p",[v._v("在 restore database 语句中使用 with recovery 选项后，数据库将不能再使用后续备份进行恢复。")]),v._v(" "),n("p",[v._v("通常数据库的转储机制有三种，分别是完全转储、差量转储和{增量}转储。")]),v._v(" "),n("p",[v._v("完全转储：是指对整个数据库中的数据全部重新备份，效率低，时间长；")]),v._v(" "),n("p",[v._v("差量转储是基于上一次完全转储以来发生的数据变化进行转储，是对上次转储之后对所有文件中修改或删除的记录的转储，效率高，时间短。")]),v._v(" "),n("p",[v._v("增量转储是对数据库中凡是有记录变化的文件的整个文件进行复制，效率介于前两种转储方式之间。只复制上次转储后发生变化的文件或数据块。时间和空间都小。只能和完全转储配合。")]),v._v(" "),n("p",[v._v("增量转储的恢复时间比完全存储要长。")]),v._v(" "),n("p",[v._v("差量转储和完全相比，速度快，占用空间小。")]),v._v(" "),n("p",[v._v("差量转储和增量比，速度慢、占用空间多，但是恢复速度快。")]),v._v(" "),n("p",[v._v("增量转储和差量转储相比速度快，存储空间占用少。")]),v._v(" "),n("p",[v._v("静态转储可以保证数据的有效性，但是却降低数据库的可用性。\n动态转储可以提高数据库的可用性，但数据的有效性得不到保证。为了保证数据的一致性，需使用日志文件和动态转储结合使用。")]),v._v(" "),n("p",[v._v("设某数据库服务器中有 3 块 146G 的 SAS 硬盘，为了保证数据的安全性，数据库管理员利用硬件 RAID 卡将三块硬盘做成 RAID5，则服务器可使用硬盘空间为{292}GB。\nRAID5 的磁盘容量为硬盘总数-1，为 2×146=292GB。")]),v._v(" "),n("p",[v._v("备份日志 BACKUP LOG\n设 SQL Server 2008 中有 students 数据库，需要对其进行事务日志备份，直接备份到 D:LogData 目录下（此目录已存在）的 Students_log.bak 文件上，请补全下列语句：\nBACKUP {LOG} students TO DISK =’D:\\LogData\\Students_log.bak’\n语法：BACKUP LOG 数据库名 TO 备份的地方")]),v._v(" "),n("p",[v._v("日志文件的具体作用：")]),v._v(" "),n("ol",[n("li",[v._v("事务故障恢复和系统故障恢复必须使用日志文件")]),v._v(" "),n("li",[v._v("在动态转储方式中必须建立日志文件。")]),v._v(" "),n("li",[v._v("在静态转储方式中，也可以建立日志文件。登记日志文件必须遵循两条原则：登记的次序严格按并行事务执行的时间次序，必须先写日志文件，后写数据库。")])]),v._v(" "),n("p",[v._v("数据文件的空间使用量未必比日志文件大，因为日志是快速增长的。")]),v._v(" "),n("p",[v._v("使用日志备份并不能降低数据库的备份空间。")]),v._v(" "),n("p",[v._v("日志文件占用空间小，但备份比完整备份频繁。因此保留时间比完整备份短。")]),v._v(" "),n("p",[v._v("事务日志用于保存对数据的更新操作。")]),v._v(" "),n("p",[v._v("事务日志能够实现数据恢复。")]),v._v(" "),n("p",[v._v("不同的数据库管理系统采用的日志文件格式不完全一样，概括起来主要有以记录为单位的日志文件和以{数据块}为单位的日志文件两种。")]),v._v(" "),n("p",[v._v("在数据库恢复过程中，检查点技术大幅度减少了数据库恢复时执行的{日志}恢复操作数量。")]),v._v(" "),n("p",[v._v("检查点记录的内容：")]),v._v(" "),n("ol",[n("li",[v._v("建立检查点时刻所有正在执行的事务清单；")]),v._v(" "),n("li",[v._v("这些事务最近一个日志记录的地址。")]),v._v(" "),n("li",[v._v("恢复子系统可以定期或不定期地建立检查点来保存数据库状态。")]),v._v(" "),n("li",[v._v("系统在恢复时，如果事务在故障发生时未完成，应当 UNDO；")]),v._v(" "),n("li",[v._v("如果事务在检查点之后才提交，它们对数据库所做的修改在故障发生时还可能在缓冲区中，尚未写入数据库，所以要 REDO；")]),v._v(" "),n("li",[v._v("如果事务在检查点之前已经提交，所以不必执行 REDO 操作。")])]),v._v(" "),n("p",[v._v("在检查点建立的同时，数据库管理系统会将当前数据缓冲区中的所有数据记录写入数据库中。")]),v._v(" "),n("p",[v._v("检查点技术大幅度减少了数据库完全恢复时所必须执行的日志部分。")]),v._v(" "),n("p",[v._v("使用检查点进行恢复时需要从“重新开始文件”中找到最后一个检查点记录在日志文件中的地址。")]),v._v(" "),n("p",[v._v("在数据库系统出现系统故障后进行恢复时，对于事务 T，如果在日志文件中有 BEGIN TRANSACTION 记录，也有 COMMIT 记录，但其对数据的修改没有写到数据库中，则数据库管理系统处理这种事务时应执行的操作是{REDO}。")]),v._v(" "),n("p",[v._v("事务是由一系列操作组成的，事务的执行表现为事务中各个操作的执行。每个事务应具有结束操作。当一个事务发生故障需要终止并取消所有已执行的数据修改时应执行{UNDO}操作。")]),v._v(" "),n("p",[v._v("对于故障发生前已提交的事务（既有 BEGIN Transaction，又有 commit）做 redo（重做）操作。")]),v._v(" "),n("p",[v._v("对于故障发生时尚未完成的事务（只有 BEGIN Transaction，而没有 commit 或 rollback）做 undo（撤销）操作。")]),v._v(" "),n("p",[v._v("数据库在运行过程中，由于突然停电等情况，导致系统停止运行的故障称为{系统故障}。")]),v._v(" "),n("p",[v._v("系统故障又称软故障，是指数据库在运行过程中，由于硬件故障、数据库软件及操作系统的漏洞、突然停电等情况，导致系统停止运转，所有正在运行的事务以非正常方式终止，需要系统重新启动的一类故障。")]),v._v(" "),n("p",[v._v("硬件容错最完全的方法是设计两套相同的数据库系统同时工作，变化也同步，空间有一定的距离，因此同时破坏两套的概率几乎为零。")]),v._v(" "),n("p",[v._v("将经常一起使用的多个表中的数据行按照其公共列值存储在一起，这种表存储方法为{聚集}。")]),v._v(" "),n("p",[v._v("事务特性：")]),v._v(" "),n("ol",[n("li",[v._v("原子性：事务的所有操作在数据库中要么全部正确反映出来，要么全部不反映。")]),v._v(" "),n("li",[v._v("一致性：事物的隔离执行（即没有并发执行的其他事物），保持数据库的一致性。")]),v._v(" "),n("li",[v._v("隔离性：尽管多个事务可以并发执行，但系统必须保证，对任一对事务 Ti 和 Tj，在 Ti 看来，Tj 或者在 Ti 开始之前已经停止执行，或者在 Ti 完成之后开始执行。这样，每个事务都感觉不到系统中有其他事务在并发的执行。")])]),v._v(" "),n("p",[v._v("在一个事务执行过程中，其正在访问的数据被其他事物所修改，导致处理结果不正确，这是由于违背了事务性质中的{隔离}性而引起的")]),v._v(" "),n("ol",{attrs:{start:"4"}},[n("li",[v._v("持久性：一个事务成功完成后，它对数据库的改变必须是永久的，即使系统可以出现故障。")])]),v._v(" "),n("p",[v._v("事务故障包括预期内的事务故障和非预期的事务故障，两种事务故障的恢复都是由系统自动完成的。对用户是透明的。（不需要管理员人工干预）")]),v._v(" "),n("p",[v._v("可预期的事务内部故障可以通过将事务回滚，使数据库达到一致性状态。")]),v._v(" "),n("p",[v._v("应用程序编写不当可能导致数据库中出现死锁，由于死锁导致的事务回滚属于数据库故障中的{事务内部}故障。")]),v._v(" "),n("p",[v._v("非预期的事务内部故障：运算溢出故障、并发事务发生死锁而被撤销该事务、违反了某些完整性限制等。")]),v._v(" "),n("p",[v._v("在数据库操作过程中，因发生了违反完整性约束而导致事务中止的故障属于{非预期}的事务内部故障。")]),v._v(" "),n("p",[v._v("数据库镜像：\n增强数据保护功能。数据库镜像提供完整或接近完整的数据冗余，具体取决于运行模式是高安全性模式还是高性能模式。\n提高数据库的可用性。发生灾难时，在具有自动故障转移功能的高安全性模式下，自动故障转移可快速使数据库的备用副本在线（而不会丢失数据）。在其他运行模式下，数据库管理员可以选择强制服务（可能丢失数据），以替代数据库的备用副本；\n提供生产数据库在升级期间的可用性。")]),v._v(" "),n("p",[v._v("数据库镜像分为高{可用}操作模式、高保护操作模式和高性能操作模式。")]),v._v(" "),n("p",[v._v("第 12 章 备份与恢复数据库")]),v._v(" "),n("p",[v._v("在进行数据恢复时，首先恢复完全备份，其次恢复差异备份，最后恢复日志备份。\n备份日志时使用 Norecovery 用来备份尾日志，这样备份日志的时候数据库处于恢复状态，别的进程就不能再访问数据库，日志就不会再增加，因此在还原的时候就可以正常恢复。\n还原备份的时候如果想同时还原之后的日志，必须加上 Norecovery 才可以还原，如果有多个日志备份，除了最后一个日志备份外，还原其他日志也必须加上 Norecovery。")]),v._v(" "),n("p",[v._v("SQL Server 不支持在 master 数据库上进行差异备份、事务日志备份以及文件备份。（应用在 master 上的）")]),v._v(" "),n("p",[v._v("数据库的恢复顺序如下：")]),v._v(" "),n("ol",[n("li",[v._v("恢复最近的完全数据库备份。")]),v._v(" "),n("li",[v._v("恢复完全备份之后的最近的差异数据库备份。")]),v._v(" "),n("li",[v._v("按日志备份的先后顺序恢复自最近的完全或差异数据库备份之后的所有日志备份。")])]),v._v(" "),n("p",[v._v("结尾日志备份可以包括纯日志记录或者大容量操作日志记录。")]),v._v(" "),n("p",[v._v("纯日志记录不包含大容量操作日志记录。")]),v._v(" "),n("p",[v._v("数据库备份分为以下两种：")]),v._v(" "),n("ol",[n("li",[v._v("完全备份：备份所有数据和日志。")]),v._v(" "),n("li",[v._v("差异备份：备份自上一次数据库完全备份以来产生的数据改变。")])]),v._v(" "),n("p",[v._v("SQL Server 2008 支持三种恢复模式，即简单恢复模式、完整恢复模式和大容量日志恢复模式。\n简单恢复：无日志备份。自动回收日志空间以减少空间需求，实际上不再需要管理事务日志空间。最新备份之后的更改不受保护。在发生灾难时，这些更改必须重做。只能回复到备份的结尾。只用于测试和开发数据库。或用于主要包含只读数据的数据库（如数据仓库）。\n完整恢复：需要日志备份。数据文件丢失或损坏不会导致丢失工作。可以恢复到任意时点。（例如应用程序或用户错误之前）")]),v._v(" "),n("p",[v._v("使用完整恢复模式条件：")]),v._v(" "),n("ol",[n("li",[v._v("您必须能够恢复所有数据；")]),v._v(" "),n("li",[v._v("数据库包含多个文件组，并且您希望逐段还原读/写辅助文件组（以及可选地还原只读文件组）。")]),v._v(" "),n("li",[v._v("您必须能够恢复到故障点。")]),v._v(" "),n("li",[v._v("您希望可以还原单个数据页。")]),v._v(" "),n("li",[v._v("您愿意承担事务日志备份的管理开销。")])]),v._v(" "),n("p",[v._v("系统能够容忍的数据丢失时间为 1 小时，则设置完整恢复模式。")]),v._v(" "),n("p",[v._v("大容量日志恢复：需要日志备份。是完整恢复模式的附加模式，允许执行高性能的大容量复制操作。通过使用最小方式记录大多数大容量操作，减少日志空间使用量。不支持时点恢复")]),v._v(" "),n("p",[v._v("SQL Server 2008 支持在备份数据库的过程中，可以对数据库数据进行增、删、改等操作，因此，备份并不影响用户对数据库的操作，而且在备份数据库时还能将在备份过程中所发生的操作也全部备份下来。")]),v._v(" "),n("p",[v._v("SQL Server 支持对数据库中的一个数据文件进行还原的操作，在还原过程中数据库自动处于脱机状态，其他的文件都将不能进行读写操作。")]),v._v(" "),n("p",[v._v("在进行数据库还原的过程中可以将数据库移动到其他位置。")]),v._v(" "),n("p",[v._v("WITH DIFFERENTIAL，NOINIT 中\nWITH DIFFERENTIAL 表示进行数据库差异备份。\n没有该选项表示进行完整数据库备份（默认）。\nNOINIT 表示将该次备份内容追加到指定的媒体集上，以保留原有的备份集。")]),v._v(" "),n("p",[v._v("恢复数据库 RESTORE DATABASE"),n("br"),v._v("\n恢复事务日志 RESTORE LOG\n设 SQL Server 2008 中有 students 数据库，在简单恢复模式下已经对其进行了完整数据库备份，且备份到了 MyBK_1 设备上，设此设备上仅有此次备份数据。请补全恢复此数据库的 SQL 语句：{RESTORE} DATABASE students FROM MyBK_1")]),v._v(" "),n("p",[v._v("在 SQL Server 2008 中，事务日志备份仅可用在完整恢复模式和{大容量}日志恢复模式中。")]),v._v(" "),n("p",[v._v("在 SQL Server 2008 中，使用 T-SQL 语句进行数据库备份操作，需要使用{DIFFERENTIAL}关键词指定该备份为差异备份")]),v._v(" "),n("p",[v._v("SQL Server 2008 中有 3 中类型的事务日志备份，对可能损坏的数据库进行日志备份的方式是{结尾}备份。")]),v._v(" "),n("p",[v._v("备份策略的制定包括定义备份的类型和频率、备份所需硬件的特性和速度、备份的测试方法以及备份媒体的存储位置和方法。")]),v._v(" "),n("p",[v._v("第十三章大规模数据库架构")]),v._v(" "),n("p",[v._v("分布透明性\n分布式数据库中的分布透明性包括分片透明性、位置透明性、局部数据模型透明性。")]),v._v(" "),n("p",[v._v("其中分片透明性是最高层次的透明性，用户只需对全局关系进操作，位于全局概念模式和分片模式之间。")]),v._v(" "),n("p",[v._v("分布透明性目的在于使用户完全感觉不到数据是分布的，使用户的使用方式与集中式数据库完全一样。")]),v._v(" "),n("p",[v._v("位置透明性是下一层次，指用户或应用程序只需了解数据分片情况，而不必了解片段的存储场地。位于分片模式与分配模式之间。")]),v._v(" "),n("p",[v._v("在分布式数据库中，如果用户编写程序时不必了解数据分片在各个场地的分配情况，则称该分布式数据库系统具有{位置}透明性。")]),v._v(" "),n("p",[v._v("局部数据模型透明性指的是用户或用户程序不必了解局部场地上使用的是哪种数据模型，但是必须了解全局数据的分片情况，还需了解各片断的副本复制情况及各片断和它们副本的场地位置分配情况。位于分配模式与局部概念模式之间")]),v._v(" "),n("p",[v._v("分布式数据库系统由局部数据库管理系统、{全局数据库管理系统}、全局数据字典、通信管理四部分组成。")]),v._v(" "),n("p",[v._v("全局数据库管理系统时分布式数据库管理系统的核心，它为终端用户提供分布透明性，协调全局事务在各个场地的执行，为全局应用提供支持。")]),v._v(" "),n("p",[v._v("局部数据库管理系统负责创建和管理局部数据库，提供场地自制能力，执行全局应用以及全局查询的子查询。")]),v._v(" "),n("p",[v._v("全局外模式：全局应用的用户视图，即终端用户看到的逻辑上并未分布的表、视图等。\n局部内模式：局部概念模式涉及的数据在本场地的物理存储。")]),v._v(" "),n("p",[v._v("局部概念模式：全局关系在场地上存储的物理片段的逻辑结构以及特征。\n全局概念模式：全体数据的逻辑结构和特征。")]),v._v(" "),n("p",[v._v("位置独立性、数据分片独立性和数据复制独立性是使分布式数据库具有分布式透明性的主要因素。")]),v._v(" "),n("p",[v._v("分布式数据库的目标是本地自治、非集中式管理、高可用性、位置独立性、数据分片独立性。")]),v._v(" "),n("p",[v._v("分布式数据库查询中，导致数据传输通信代价大的主要原因是各个站点分片间的连接和并操作。")]),v._v(" "),n("p",[v._v("传输的代价是：I/O 代价+CPU 代价+通信代价。")]),v._v(" "),n("p",[v._v("分布式数据库查询优化的首要目标：使查询执行时通信代价最省。")]),v._v(" "),n("p",[v._v("在分布式数据库中，采用{半}连接操作可以减少场地之间的数据传输量。")]),v._v(" "),n("p",[v._v("分布式数据库系统的主要目的是实现场地自治和数据全局透明共享。")]),v._v(" "),n("p",[v._v("基本特征：本地自治、非集中式管理以及高可用性。")]),v._v(" "),n("p",[v._v("并行数据库系统的主要目的是通过高速通信介质连接多个可独立处理的单元以并行执行的方式完成对数据库系统的互联查询、内部查询及各种内部操作。")]),v._v(" "),n("p",[v._v("分布式数据库系统的恢复控制采用的最典型策略是基于{两}阶段的提交协议。")]),v._v(" "),n("p",[v._v("分布式数据库系统是物理上分散、逻辑上集中的数据库系统。\n.\n分片\n分布式数据库分片类型：\n水平分片：按一定条件把全局关系的所有元组划分成若干不相交的子集，每个子集都是关系的一个片段。\n垂直分片：把一个全局关系的属性集分成若干子集，并在这些子集上作投影运算，每个投影称为垂直分片。\n导出分片：又称为导出水平分片，即水平分片的条件不是本关系属性的条件，而是其他关系属性的条件。\n混合分片：以上三种方法的混合。")]),v._v(" "),n("p",[v._v("数据的水平分片是在关系中从行（元组）的角度依据一定条件划分为不同的片段，关系中的每一行必须至少属于一个片段，以便在需要时可以重构关系。")]),v._v(" "),n("p",[v._v("数据垂直分片是在关系中列（属性）的角度依据一定条件分为不同的片段，各片段中应该包含关系的主码，以便通过连接方法恢复关系")]),v._v(" "),n("p",[v._v("分片是对关系的操作\n分配是对分片结果的操作。\n分片模式：每个数据片段以及全局关系到片段的映像。")]),v._v(" "),n("p",[v._v("分配模式：各片段打到物理存放场地的映像。")]),v._v(" "),n("p",[v._v("在分布式数据库中，使用{分配}模式来描述各片段到物理存放场地的映像。")]),v._v(" "),n("p",[v._v("分片模式：每个数据片段以及全局关系到片段的映像，是分布式数据库系统中全局数据的逻辑划分视图。")]),v._v(" "),n("p",[v._v("分配模式：各片断到物理存放场地的映像。")]),v._v(" "),n("p",[v._v("分片有以下三个原则：\n完整性原则：即全局关系的所有数据项必须包含在某个片段中，否则将导致数据库不完整，造成某些片段数据丢失。\n重构性原则：即所有片段必须能够还原全局关系。\n不相交原则：对于一个全局关系，要保证数据不丢失，则必须要属于某个片段，即不允许不属于任何一个片段，也不允许一个全局关系的某些数据既属于该全局关系的某些片段又属于该全局关系的另一个片段。（不允许某些数据同时属于不同的片段）")]),v._v(" "),n("p",[v._v("并行数据库常用的划分技术有轮转法、散列划分、范围划分。\n轮转法：对关系顺序扫描，将第 i 个元组存储到标号为 Dimod 的磁盘上；该方式保证了元组在多个磁盘上均匀分布。（整表扫描、）\n散列划分：选定一个值域为{0,1，...n-1}的散列函数，对关系中的元组基于划分属性进行散列。如果散列函数返回 i，则将其存储到第 i 个磁盘。例：WHERE R.A=S.A（点查询、顺序扫描关系）\n范围划分：该策略按照关系中某个属性的取值范围将数据文件划分为几部分，分别存放到磁盘上。（范围查询和点查询）")]),v._v(" "),n("p",[v._v("设某并行数据库采用一台具有 14 个刀片的刀片服务器，每个刀片具有独立的内存和磁盘，各刀片之间通过刀片服务器的以太网交换机实现通信，则该并行数据库采用的体系结构是{无共享}结构。")]),v._v(" "),n("p",[v._v("并行数据库服务器分为两种结构：完全共享资源结构、完全无共享资源结构。\n共享：共享内存、磁盘等资源。")]),v._v(" "),n("p",[v._v("无共享：独立的内存和磁盘。（银行，出纳，民航售票等 OLTP 类）")]),v._v(" "),n("p",[v._v("无共享结构通过最小化共享资源来降低资源竞争的概率，具有很高的扩展性，适合 OLTP 应用。\n层次结构分为两层，顶层是无共享结构，底层是共享内存结构。")]),v._v(" "),n("p",[v._v("在各种并行数据库系统结构中，{层次}结构综合了共享内存、共享磁盘和无共享结构的特点，将结构分成顶层和底层两层，顶层是无共享结构，底层是共享内存或共享磁盘结构。")]),v._v(" "),n("p",[v._v("共享内存结构的系统中，如果处理器数量过多，容易造成内存访问冲突。")]),v._v(" "),n("p",[v._v("并行数据库有多种体系结构，其中所有处理机通过网络共享一个公共的主存储器的结构称为{共享内存}结构。")]),v._v(" "),n("p",[v._v("分布式数据库的分配方式包括集中式、分割式、全复制式、混合式。\n集中式指所有数据片段都安排在一个场地上；\n分割式指全局数据有且只有一份，它们被分割成若干片段，每个片段被分配在一个特定场地上；\n全复制式是在每个站点上都有全局数据的复制样本，数据的冗余性最大；\n混合式指全局数据被分为若干个数据子集，每个子集被安排在一个或多个不同的场地上，但是每个场地未必保存所有数据。（介于分割式和全复制式的分布方式）")]),v._v(" "),n("p",[v._v("架构是形成单个命名空间的数据库实体的集合。命名空间也是一个集合，其中每个元素的名称都是唯一的。\n架构与用户的关系是一对多的关系，一个用户只能对应一个架构，但多个用户可以共享一个架构。")]),v._v(" "),n("p",[v._v("XML 数据库需要对 XML 文档进行解析，因为 XML 文档的本身标记只是文档自身的描述，需要经过数据库的解析才能达到具体的用途。")]),v._v(" "),n("p",[v._v("XML 数据库包括 XEDB、NXD 和 HXD 三种类型。")]),v._v(" "),n("p",[v._v("很多关系数据库厂商在其传统的数据库产品中进行了扩充，使其能够处理 XML 文档。")]),v._v(" "),n("p",[v._v("在数据本身具有层次特征时，XML 文档能够清晰地表达数据的层次特征。")]),v._v(" "),n("p",[v._v("在 SQL Server 2008 中，可以在查询语句里加入{FOR XML}子句实现以 XML 格式返回查询结果。")]),v._v(" "),n("p",[v._v("XML 数据库适合管理复杂数据结构的数据集，当数据本身具有层次特征时，由于 XML 数据格式能够清晰表达数据的层次特性，因此 XML 数据库便于层次化的数据进行操作。")]),v._v(" "),n("p",[v._v("XML 数据库能够对半结构化数据进行有效的存取和管理。")]),v._v(" "),n("p",[v._v("提供对标签和路径的操作。")]),v._v(" "),n("p",[v._v("事务的四大特性：原子性、一致性、隔离性、持久性。\n原子性：事务中包括的诸多操作为了保持一致性要么都做，要么都不做。\n一致性：事务执行结果从一个一致性到另一个一致性的变化。\n隔离性：保证其并行结果正确性。\n持久性：对其数据库的改变是永久的，结果不受影响。")]),v._v(" "),n("p",[v._v("在分布式数据库系统中，为了保证全局事务的原子性，参与事务执行的所有场地或者全部提交，或者全部{撤消}。")]),v._v(" "),n("p",[v._v("调度分为串行调度和并发调度。")]),v._v(" "),n("p",[v._v("串行调度的特点是一个事务的所有操作都执行完才开始执行另一事务，不存在事务操作的交叉执行。")]),v._v(" "),n("p",[v._v("不同事物操作的交叉执行称为并发调度，DBMS 交叉执行来自多个事务的各个操作，以提高数据库系统的性能。")]),v._v(" "),n("p",[v._v("并发调度中不同的事务的操作可以交叉执行。")]),v._v(" "),n("p",[v._v("为了保证正确地调度事务的并发操作，事务对数据库对象加锁、解锁需遵守加锁协议。加锁协议中两阶段加锁协议可以保证事务调度{可串行}性。")]),v._v(" "),n("p",[v._v("两段锁协议就是实现可串行导读的协议。")]),v._v(" "),n("p",[v._v("Google 的云数据库是一个分布式的结构化数据存储系统，称为{Bigtable}。")]),v._v(" "),n("p",[v._v("Bigtable 数据模型的特点是：")]),v._v(" "),n("ol",[n("li",[v._v("表中的关键字可以是任意的字符串")]),v._v(" "),n("li",[v._v("列族是由列关键字组成的集合，是访问控制的基本单位。")]),v._v(" "),n("li",[v._v("时间戳记录了 BigTable 是每一个数据项所包含的不同版本的数据的时间标识。在 BigTable 中，不仅可以随意地增减行的数量，在一定的约束条件下，还可以对列的数量进行扩展。")])]),v._v(" "),n("p",[v._v("主备方式（Active-Standby 方式）")]),v._v(" "),n("p",[v._v("云计算中，SaaS 是指{软件}即服务。\nPaas：平台即服务")]),v._v(" "),n("p",[v._v("云计算通过集中所有的计算资源，采用硬件{虚拟}技术，为使用者提供强大的计算能力、存储和带宽等资源。")]),v._v(" "),n("p",[v._v("架构与用户的关系是一对多关系，一个用户只能对应一个架构，但多个用户可以共享一个架构。")]),v._v(" "),n("p",[v._v("第 14 章 数据仓库与数据挖掘")]),v._v(" "),n("p",[v._v("数据仓库有若干基本特征，包括不可更新性和随时间变化性。\n不可更新性：用户在提取仓库中的数据进行分析时并不会同时对数据仓库中的数据进行更新操作。不允许对数据做直接更改\n数据变化性：是数据仓库每隔一段时间进行数据的更新和处理。不会实时更新。\n（没有实时性）")]),v._v(" "),n("p",[v._v("数据仓库是一个面向{主题}的、集成的、非易失的、且随时间变化的数据集合。")]),v._v(" "),n("p",[v._v("在数据仓库设计和建设过程中，设计者需要调查用户的决策或数据处理需求，并将功能相近且需要相关联数据支持的需求进行归类，得到不同的需求集合，并在企业数据模型中寻找能够满足各个需求集合的数据集合，然后针对各个数据集合开展数据仓库数据模型的设计。这种设计方法称为{面向主题}的设计方法。")]),v._v(" "),n("p",[v._v("在数据仓库中，元数据主要分为{技术}元数据和业务元数据两类。")]),v._v(" "),n("p",[v._v("建立数据仓库的主要目的：根据决策需求对企业的数据采取适当的手段进行集成，形成一个综合的、面相分析的数据环境，用于支持企业的信息型、决策型的分析应用。")]),v._v(" "),n("p",[v._v("数据仓库是一个面向主题、集成的、时变的、非易失的数据集合，支持管理部门的决策过程，数据仓库通过数据转移从多个数据源提取数据，为了解决不同数据源格式上的不统一，需要进行的数据操作是{转换}。\n数据转换的主要任务是对数据粒度以及不一致的数据进行转换。")]),v._v(" "),n("p",[v._v("数据仓库的数据模型一般被划分为概念模型、{逻辑}模型和物理模型。")]),v._v(" "),n("p",[v._v("数据仓库的数据分析需求一般在设计初期就要尽可能完善。")]),v._v(" "),n("p",[v._v("数据从操作型环境转移到数据仓库过程中所用到 ETL 工具通常需要完成的处理操作包括抽取、转换和{装载}。")]),v._v(" "),n("p",[v._v("在数据仓库的导出数据或物化视图（实视图）的维护策略中，只在用户查询时发现数据已经过期才进行更新的策略称为{延时}维护策略。")]),v._v(" "),n("p",[v._v("在数据仓库中，根据数据源的变化量在维护对象原有数据的基础上对数据进行维护的方法称为{增量}维护法")]),v._v(" "),n("p",[v._v("决策支持系统一般是指企业中以数据为基础对重要业务或事务实施辅助决策的信息系统。")]),v._v(" "),n("p",[v._v("知识发现主要由三个步骤组成，它们是{数据准备}、数据挖掘、结果的解释评估。")]),v._v(" "),n("p",[v._v("快照：该方法通过对当前数据表进行“照相”，记录当前的数据表信息“相片”，然后将当前的“相片”与以前的数据表“相片”进行比较，如果不一致将通过一定的方式传到数据仓库，从而实现数据的一致性，这种方式适合于更新频率较低的数据表。书评表和乐评表更新频率较高不适合用于快照的方法。")]),v._v(" "),n("p",[v._v("元数据：关于数据的数据，或者叫做描述数据的数据。\n元数据描述了数据的结构、内容、链和索引等项内容。\n在关系数据中，这种描述就是对数据库、表、列等其他对象的定义。")]),v._v(" "),n("p",[v._v("粒度是反映数据库系统中综合程度的指标。设有表 T1（商品标识，销售时间，销售量）、T2（商品标识、日期，总销售量）和 T3（商品类别，月份，总销售量），其中粒度最大的表是{T3}。\n解析：粒度问题是设计数据仓库的一个最重要方面。粒度是指数据仓库的数据单位中保存数据的细化或综合程度的级别。\n细化程度越高，粒度级就越小；综合程度也越小，数据量越大。空间代价也大。\n相反，细化程度越低，粒度级就越大，综合程度也越大。")]),v._v(" "),n("p",[v._v("在数据仓库环境中，数据的{粒度}设计是一种重要的设计问题，它会影响到数据仓库中数据量以及系统能回答的查询的类型。")]),v._v(" "),n("p",[v._v("主要考虑的因素：用户查询所涉及的数据的最低细节程度、用户查询的平均性能需求、系统的可用存储空间、低粒度级数据的规模。")]),v._v(" "),n("p",[v._v("在数据库并发控制中，锁的粒度越{大}，事务并发执行程度就越小，数据库系统开销也越小。\n粒度越小，则并发度就越大，开销也大。")]),v._v(" "),n("p",[v._v("对于训练集 S，测试集 A 利用数据挖掘中的分类算法，通过训练集构建一个分类器，将测试集 A 作为分类器输入，经过分类器后会得到相应的类别号。")]),v._v(" "),n("p",[v._v("在构造分类器时，需要一个训练样本数据集作为输入。")]),v._v(" "),n("p",[v._v("分类器的构造方法：统计方法、机器学习方法、神经网络方法。")]),v._v(" "),n("p",[v._v("在分类预测任务中，需要用到的数据一般包括{训练}集、测试集和验证集。")]),v._v(" "),n("p",[v._v("常见的数据挖掘任务包括分类、估计、预测、相关性分组或关联规则、聚类和描述、可视化以及复杂数据类型挖掘。")]),v._v(" "),n("p",[v._v("分类分析：首先从数据中选出已经分好类的训练集，在该训练集上运用数据挖掘分类的技术，建立分类模型，对于没有分类的数据进行分类。")]),v._v(" "),n("p",[v._v("聚类是一类常见的机器学习方法，聚类算法所处理的数据对象一般都没有标记，因此聚类一般也被称为{无监督}的学习方法")]),v._v(" "),n("p",[v._v("聚类就是将一个数据集中的数据进行分组，使得每一组内的数据尽可能地相似而不同组间的数据尽可能地不同。")]),v._v(" "),n("p",[v._v("聚类方法：统计方法、机器学习方法、神经网络方法和面向数据库的方法。")]),v._v(" "),n("p",[v._v("K-means 属于聚类算法。")]),v._v(" "),n("p",[v._v("与分类相比，分类的例子或数据对象均有类别标记，而聚类的例子则没有标记。")]),v._v(" "),n("p",[v._v("统计方法：贝叶斯法和非参数法。")]),v._v(" "),n("p",[v._v("机器学习方法：决策树法和规则归纳法。")]),v._v(" "),n("p",[v._v("神经网络方法：BP 算法")]),v._v(" "),n("p",[v._v("给定一个销售交易数据库，从中找出这些交易中的某些物品和其他物品之间的关系，这种数据挖掘一般称为{关联}挖掘。")]),v._v(" "),n("p",[v._v("时间序列分析也可以成为数据演变分析，描述行为对象随时间变化的规律或趋势，并进行建模的数据挖掘方法。")]),v._v(" "),n("p",[v._v("ODS 是数据仓库体系结构中的一个可选部分，ODS 具备数据仓库的部分特征和 OLTP 系统的部分特征，它是“面向主题的、继承的、当前或接近当前的、不断变化的“数据”。”\n第一类 ODS 数据更新频率是秒级。\n第二类 ODS 的数据更新频率是小时级。\n第三类 ODS 的数据更新频率是天级。\n上述三类是根据数据更新的速度划分的。\nODSIV：第四类 ODS 是根据数据来源方向和类型划分的。")]),v._v(" "),n("p",[v._v("在企业数据仓库架构中，操作型数据存储 ODS 一般情况下主要用来支持即时 OLAP 和全局型{OLTP}两类应用。")]),v._v(" "),n("p",[v._v("在 ODS 上可实行的全局应用大致可分为：实现企业全局的 OLTP 操作、实现即时的 OLAP 操作。")]),v._v(" "),n("p",[v._v("联机事务处理（OLTP）：对数据库联机的日常操作，通常是对一条记录的查询和修改，要求快速响应用户的请求，对数据的安全性、完整性及事务吞吐量要求很高。")]),v._v(" "),n("p",[v._v("执行的事务内容比较简单且重复率高。")]),v._v(" "),n("p",[v._v("为了进行数据分析，将 OLTP 系统中数据利用抽取程序抽取出来的最主要原因是解决 OLTP 应用与分析型应用之间的性能冲突问题。")]),v._v(" "),n("p",[v._v("联机分析处理（OLAP）：对数据的查询和分析操作，通常是对海量历史数据的查询和分析，要访问的数据量非常大，查询和分析操作十分复杂。（企业中上层使用）")]),v._v(" "),n("p",[v._v("在 OLAP 的实现方式中，以多维数据作为存储结构的被称作{M}OLAP")]),v._v(" "),n("p",[v._v("OLAP 主要用于支持复杂的分析操作，侧重对决策人员和高层管理人员的数据支持。OLAP 的实现方式主要有三种：MOLAP、{ROLAP}和 HOLAP。\n基于关系型数据库的 DLAP（ROLAP）；\n基于多维数据库的 OLAP（MOLAP）；\n混合型 OLAP（HOLAP）；")]),v._v(" "),n("p",[v._v("在进行多维分析时，如果将年销售额投影到每个月上来进行观察，这种分析动作被称为{钻取}。")]),v._v(" "),n("p",[v._v("常见的 OLAP 多维分析操作有切片、切块、旋转、钻取和卷起。\n卷起：数据立方体中执行聚集操作。\n钻取：通过在维级别中下降或通过引入某个或某些维来更细致的观察数据。\n在多维数据分析中，从高粒度级数据视图切换到低粒度级数据视图的分析操作称为{钻取}操作。\n切片和切块：实现局部数据的显示，帮助用户从众多混杂的数据中进行选择。\n旋转：就是改变维的方向。")]),v._v(" "),n("p",[v._v("在关联规则挖掘中，关联规则的成立与否一般用{支持}度和置信度两个指标进行描述。")]),v._v(" "),n("p",[v._v("支持度和置信度")])])}),[],!1,null,null,null);_.default=t.exports}}]);